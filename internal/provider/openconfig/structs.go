// SPDX-FileCopyrightText: 2025 SAP SE or an SAP affiliate company and IronCore contributors
// SPDX-License-Identifier: Apache-2.0

/*
Package openconfig is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by ygnmi version: v0.12.0: (ygot: v0.29.20)
using the following YANG input files:
  - ./yang/release/models/interfaces/openconfig-interfaces.yang
  - ./yang/release/models/interfaces/openconfig-if-ip.yang
  - ./yang/third_party/ietf/iana-if-type.yang

Imported modules were sourced from:
  - ./yang/doc
  - ./yang/regexp-tests
  - ./yang/release/models
  - ./yang/release/models/acl
  - ./yang/release/models/aft
  - ./yang/release/models/ate
  - ./yang/release/models/bfd
  - ./yang/release/models/bgp
  - ./yang/release/models/catalog
  - ./yang/release/models/defined-sets
  - ./yang/release/models/devices-manifest
  - ./yang/release/models/ethernet-segments
  - ./yang/release/models/extensions
  - ./yang/release/models/firewall
  - ./yang/release/models/flex-algo
  - ./yang/release/models/gnpsi
  - ./yang/release/models/gnsi
  - ./yang/release/models/gribi
  - ./yang/release/models/grpc
  - ./yang/release/models/interfaces
  - ./yang/release/models/isis
  - ./yang/release/models/keychain
  - ./yang/release/models/lacp
  - ./yang/release/models/lldp
  - ./yang/release/models/local-routing
  - ./yang/release/models/macsec
  - ./yang/release/models/mpls
  - ./yang/release/models/multicast
  - ./yang/release/models/network-instance
  - ./yang/release/models/oam
  - ./yang/release/models/openflow
  - ./yang/release/models/optical-transport
  - ./yang/release/models/ospf
  - ./yang/release/models/p4rt
  - ./yang/release/models/pcep
  - ./yang/release/models/platform
  - ./yang/release/models/policy
  - ./yang/release/models/policy-forwarding
  - ./yang/release/models/probes
  - ./yang/release/models/ptp
  - ./yang/release/models/qos
  - ./yang/release/models/relay-agent
  - ./yang/release/models/rib
  - ./yang/release/models/sampling
  - ./yang/release/models/segment-routing
  - ./yang/release/models/stp
  - ./yang/release/models/system
  - ./yang/release/models/telemetry
  - ./yang/release/models/types
  - ./yang/release/models/vlan
  - ./yang/release/models/wifi
  - ./yang/third_party/ietf
*/
package openconfig

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Device represents the /device YANG schema element.
type Device struct {
	Interface map[string]*Interface `path:"interfaces/interface" module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Device.
//
// It initializes the field if not already initialized.
func (t *Device) GetOrCreateInterfaceMap() map[string]*Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Device
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Device) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// Interface represents the /openconfig-interfaces/interfaces/interface YANG schema element.
type Interface struct {
	AdminStatus      E_Interface_AdminStatus            `path:"state/admin-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Aggregation      *Interface_Aggregation             `path:"aggregation" module:"openconfig-if-aggregate"`
	Counters         *Interface_Counters                `path:"state/counters" module:"openconfig-interfaces/openconfig-interfaces"`
	Cpu              *bool                              `path:"state/cpu" module:"openconfig-interfaces/openconfig-interfaces"`
	Description      *string                            `path:"config/description" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/description" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Enabled          *bool                              `path:"config/enabled" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/enabled" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Ethernet         *Interface_Ethernet                `path:"ethernet" module:"openconfig-if-ethernet"`
	HoldTime         *Interface_HoldTime                `path:"hold-time" module:"openconfig-interfaces"`
	Ifindex          *uint32                            `path:"state/ifindex" module:"openconfig-interfaces/openconfig-interfaces"`
	LastChange       *uint64                            `path:"state/last-change" module:"openconfig-interfaces/openconfig-interfaces"`
	Logical          *bool                              `path:"state/logical" module:"openconfig-interfaces/openconfig-interfaces"`
	LoopbackMode     E_TransportTypes_LoopbackModeType  `path:"config/loopback-mode" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/loopback-mode" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Management       *bool                              `path:"state/management" module:"openconfig-interfaces/openconfig-interfaces"`
	Mtu              *uint16                            `path:"config/mtu" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/mtu" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Name             *string                            `path:"config/name|name" module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces" shadow-path:"state/name|name" shadow-module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces"`
	OperStatus       E_Interface_OperStatus             `path:"state/oper-status" module:"openconfig-interfaces/openconfig-interfaces"`
	PenaltyBasedAied *Interface_PenaltyBasedAied        `path:"penalty-based-aied" module:"openconfig-interfaces"`
	RoutedVlan       *Interface_RoutedVlan              `path:"routed-vlan" module:"openconfig-vlan"`
	Subinterface     map[uint32]*Interface_Subinterface `path:"subinterfaces/subinterface" module:"openconfig-interfaces/openconfig-interfaces"`
	Tpid             E_VlanTypes_TPID_TYPES             `path:"config/tpid" module:"openconfig-interfaces/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-interfaces/openconfig-vlan"`
	Type             E_IETFInterfaces_InterfaceType     `path:"config/type" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/type" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewSubinterface(Index uint32) (*Interface_Subinterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterfaceMap returns the list (map) from Interface.
//
// It initializes the field if not already initialized.
func (t *Interface) GetOrCreateSubinterfaceMap() map[uint32]*Interface_Subinterface {
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}
	return t.Subinterface
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateSubinterface(Index uint32) *Interface_Subinterface {

	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetSubinterface(Index uint32) *Interface_Subinterface {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver Interface. If there is no such element, the function
// is a no-op.
func (t *Interface) DeleteSubinterface(Index uint32) {
	key := Index

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied Interface_Subinterface struct to the
// list Subinterface of Interface. If the key value(s) specified in
// the supplied Interface_Subinterface already exist in the list, an error is
// returned.
func (t *Interface) AppendSubinterface(v *Interface_Subinterface) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateAggregation retrieves the value of the Aggregation field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateAggregation() *Interface_Aggregation {
	if t.Aggregation != nil {
		return t.Aggregation
	}
	t.Aggregation = &Interface_Aggregation{}
	return t.Aggregation
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateCounters() *Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Counters{}
	return t.Counters
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateEthernet() *Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateHoldTime() *Interface_HoldTime {
	if t.HoldTime != nil {
		return t.HoldTime
	}
	t.HoldTime = &Interface_HoldTime{}
	return t.HoldTime
}

// GetOrCreatePenaltyBasedAied retrieves the value of the PenaltyBasedAied field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreatePenaltyBasedAied() *Interface_PenaltyBasedAied {
	if t.PenaltyBasedAied != nil {
		return t.PenaltyBasedAied
	}
	t.PenaltyBasedAied = &Interface_PenaltyBasedAied{}
	return t.PenaltyBasedAied
}

// GetOrCreateRoutedVlan retrieves the value of the RoutedVlan field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateRoutedVlan() *Interface_RoutedVlan {
	if t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	t.RoutedVlan = &Interface_RoutedVlan{}
	return t.RoutedVlan
}

// GetAggregation returns the value of the Aggregation struct pointer
// from Interface. If the receiver or the field Aggregation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetAggregation() *Interface_Aggregation {
	if t != nil && t.Aggregation != nil {
		return t.Aggregation
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetCounters() *Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetEthernet() *Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from Interface. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetHoldTime() *Interface_HoldTime {
	if t != nil && t.HoldTime != nil {
		return t.HoldTime
	}
	return nil
}

// GetPenaltyBasedAied returns the value of the PenaltyBasedAied struct pointer
// from Interface. If the receiver or the field PenaltyBasedAied is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetPenaltyBasedAied() *Interface_PenaltyBasedAied {
	if t != nil && t.PenaltyBasedAied != nil {
		return t.PenaltyBasedAied
	}
	return nil
}

// GetRoutedVlan returns the value of the RoutedVlan struct pointer
// from Interface. If the receiver or the field RoutedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetRoutedVlan() *Interface_RoutedVlan {
	if t != nil && t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *Interface) GetAdminStatus() E_Interface_AdminStatus {
	if t == nil || t.AdminStatus == 0 {
		return 0
	}
	return t.AdminStatus
}

// GetCpu retrieves the value of the leaf Cpu from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cpu is set, it can
// safely use t.GetCpu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cpu == nil' before retrieving the leaf's value.
func (t *Interface) GetCpu() bool {
	if t == nil || t.Cpu == nil {
		return false
	}
	return *t.Cpu
}

// GetDescription retrieves the value of the leaf Description from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Interface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetIfindex retrieves the value of the leaf Ifindex from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ifindex is set, it can
// safely use t.GetIfindex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ifindex == nil' before retrieving the leaf's value.
func (t *Interface) GetIfindex() uint32 {
	if t == nil || t.Ifindex == nil {
		return 0
	}
	return *t.Ifindex
}

// GetLastChange retrieves the value of the leaf LastChange from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Interface) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetLogical retrieves the value of the leaf Logical from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Logical is set, it can
// safely use t.GetLogical() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Logical == nil' before retrieving the leaf's value.
func (t *Interface) GetLogical() bool {
	if t == nil || t.Logical == nil {
		return false
	}
	return *t.Logical
}

// GetLoopbackMode retrieves the value of the leaf LoopbackMode from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LoopbackMode is set, it can
// safely use t.GetLoopbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LoopbackMode == nil' before retrieving the leaf's value.
func (t *Interface) GetLoopbackMode() E_TransportTypes_LoopbackModeType {
	if t == nil || t.LoopbackMode == 0 {
		return TransportTypes_LoopbackModeType_NONE
	}
	return t.LoopbackMode
}

// GetManagement retrieves the value of the leaf Management from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Management is set, it can
// safely use t.GetManagement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Management == nil' before retrieving the leaf's value.
func (t *Interface) GetManagement() bool {
	if t == nil || t.Management == nil {
		return false
	}
	return *t.Management
}

// GetMtu retrieves the value of the leaf Mtu from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Interface) GetOperStatus() E_Interface_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetTpid retrieves the value of the leaf Tpid from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return VlanTypes_TPID_TYPES_TPID_0X8100
	}
	return t.Tpid
}

// GetType retrieves the value of the leaf Type from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface) GetType() E_IETFInterfaces_InterfaceType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetAdminStatus sets the value of the leaf AdminStatus in the Interface
// struct.
func (t *Interface) SetAdminStatus(v E_Interface_AdminStatus) {
	t.AdminStatus = v
}

// SetCpu sets the value of the leaf Cpu in the Interface
// struct.
func (t *Interface) SetCpu(v bool) {
	t.Cpu = &v
}

// SetDescription sets the value of the leaf Description in the Interface
// struct.
func (t *Interface) SetDescription(v string) {
	t.Description = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface
// struct.
func (t *Interface) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetIfindex sets the value of the leaf Ifindex in the Interface
// struct.
func (t *Interface) SetIfindex(v uint32) {
	t.Ifindex = &v
}

// SetLastChange sets the value of the leaf LastChange in the Interface
// struct.
func (t *Interface) SetLastChange(v uint64) {
	t.LastChange = &v
}

// SetLogical sets the value of the leaf Logical in the Interface
// struct.
func (t *Interface) SetLogical(v bool) {
	t.Logical = &v
}

// SetLoopbackMode sets the value of the leaf LoopbackMode in the Interface
// struct.
func (t *Interface) SetLoopbackMode(v E_TransportTypes_LoopbackModeType) {
	t.LoopbackMode = v
}

// SetManagement sets the value of the leaf Management in the Interface
// struct.
func (t *Interface) SetManagement(v bool) {
	t.Management = &v
}

// SetMtu sets the value of the leaf Mtu in the Interface
// struct.
func (t *Interface) SetMtu(v uint16) {
	t.Mtu = &v
}

// SetName sets the value of the leaf Name in the Interface
// struct.
func (t *Interface) SetName(v string) {
	t.Name = &v
}

// SetOperStatus sets the value of the leaf OperStatus in the Interface
// struct.
func (t *Interface) SetOperStatus(v E_Interface_OperStatus) {
	t.OperStatus = v
}

// SetTpid sets the value of the leaf Tpid in the Interface
// struct.
func (t *Interface) SetTpid(v E_VlanTypes_TPID_TYPES) {
	t.Tpid = v
}

// SetType sets the value of the leaf Type in the Interface
// struct.
func (t *Interface) SetType(v E_IETFInterfaces_InterfaceType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	if t.LoopbackMode == 0 {
		t.LoopbackMode = TransportTypes_LoopbackModeType_NONE
	}
	if t.Tpid == 0 {
		t.Tpid = VlanTypes_TPID_TYPES_TPID_0X8100
	}
	t.Aggregation.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.Ethernet.PopulateDefaults()
	t.HoldTime.PopulateDefaults()
	t.PenaltyBasedAied.PopulateDefaults()
	t.RoutedVlan.PopulateDefaults()
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface.
func (*Interface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Aggregation represents the /openconfig-interfaces/interfaces/interface/aggregation YANG schema element.
type Interface_Aggregation struct {
	LagSpeed     *uint32                             `path:"state/lag-speed" module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	LagType      E_IfAggregate_AggregationType       `path:"config/lag-type" module:"openconfig-if-aggregate/openconfig-if-aggregate" shadow-path:"state/lag-type" shadow-module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	Member       []string                            `path:"state/member" module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	MinLinks     *uint16                             `path:"config/min-links" module:"openconfig-if-aggregate/openconfig-if-aggregate" shadow-path:"state/min-links" shadow-module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	SwitchedVlan *Interface_Aggregation_SwitchedVlan `path:"switched-vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Aggregation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Aggregation) IsYANGGoStruct() {}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Aggregation) GetOrCreateSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Aggregation_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Aggregation. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Aggregation) GetSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// GetLagSpeed retrieves the value of the leaf LagSpeed from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagSpeed is set, it can
// safely use t.GetLagSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetLagSpeed() uint32 {
	if t == nil || t.LagSpeed == nil {
		return 0
	}
	return *t.LagSpeed
}

// GetLagType retrieves the value of the leaf LagType from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagType is set, it can
// safely use t.GetLagType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagType == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetLagType() E_IfAggregate_AggregationType {
	if t == nil || t.LagType == 0 {
		return 0
	}
	return t.LagType
}

// GetMember retrieves the value of the leaf Member from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Member is set, it can
// safely use t.GetMember() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Member == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetMember() []string {
	if t == nil || t.Member == nil {
		return nil
	}
	return t.Member
}

// GetMinLinks retrieves the value of the leaf MinLinks from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinLinks is set, it can
// safely use t.GetMinLinks() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinLinks == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetMinLinks() uint16 {
	if t == nil || t.MinLinks == nil {
		return 0
	}
	return *t.MinLinks
}

// SetLagSpeed sets the value of the leaf LagSpeed in the Interface_Aggregation
// struct.
func (t *Interface_Aggregation) SetLagSpeed(v uint32) {
	t.LagSpeed = &v
}

// SetLagType sets the value of the leaf LagType in the Interface_Aggregation
// struct.
func (t *Interface_Aggregation) SetLagType(v E_IfAggregate_AggregationType) {
	t.LagType = v
}

// SetMember sets the value of the leaf Member in the Interface_Aggregation
// struct.
func (t *Interface_Aggregation) SetMember(v []string) {
	t.Member = v
}

// SetMinLinks sets the value of the leaf MinLinks in the Interface_Aggregation
// struct.
func (t *Interface_Aggregation) SetMinLinks(v uint16) {
	t.MinLinks = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Aggregation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Aggregation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SwitchedVlan.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Aggregation.
func (*Interface_Aggregation) ΛBelongingModule() string {
	return "openconfig-if-aggregate"
}

// Interface_Aggregation_SwitchedVlan represents the /openconfig-interfaces/interfaces/interface/aggregation/switched-vlan YANG schema element.
type Interface_Aggregation_SwitchedVlan struct {
	AccessVlan    *uint16                                               `path:"config/access-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/access-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InterfaceMode E_VlanTypes_VlanModeType                              `path:"config/interface-mode" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/interface-mode" shadow-module:"openconfig-vlan/openconfig-vlan"`
	NativeVlan    *uint16                                               `path:"config/native-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/native-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	TrunkVlans    []Interface_Aggregation_SwitchedVlan_TrunkVlans_Union `path:"config/trunk-vlans" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/trunk-vlans" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Aggregation_SwitchedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Aggregation_SwitchedVlan) IsYANGGoStruct() {}

// GetAccessVlan retrieves the value of the leaf AccessVlan from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccessVlan is set, it can
// safely use t.GetAccessVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccessVlan == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetAccessVlan() uint16 {
	if t == nil || t.AccessVlan == nil {
		return 0
	}
	return *t.AccessVlan
}

// GetInterfaceMode retrieves the value of the leaf InterfaceMode from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceMode is set, it can
// safely use t.GetInterfaceMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceMode == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetInterfaceMode() E_VlanTypes_VlanModeType {
	if t == nil || t.InterfaceMode == 0 {
		return 0
	}
	return t.InterfaceMode
}

// GetNativeVlan retrieves the value of the leaf NativeVlan from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NativeVlan is set, it can
// safely use t.GetNativeVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NativeVlan == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetNativeVlan() uint16 {
	if t == nil || t.NativeVlan == nil {
		return 0
	}
	return *t.NativeVlan
}

// GetTrunkVlans retrieves the value of the leaf TrunkVlans from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrunkVlans is set, it can
// safely use t.GetTrunkVlans() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrunkVlans == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetTrunkVlans() []Interface_Aggregation_SwitchedVlan_TrunkVlans_Union {
	if t == nil || t.TrunkVlans == nil {
		return nil
	}
	return t.TrunkVlans
}

// SetAccessVlan sets the value of the leaf AccessVlan in the Interface_Aggregation_SwitchedVlan
// struct.
func (t *Interface_Aggregation_SwitchedVlan) SetAccessVlan(v uint16) {
	t.AccessVlan = &v
}

// SetInterfaceMode sets the value of the leaf InterfaceMode in the Interface_Aggregation_SwitchedVlan
// struct.
func (t *Interface_Aggregation_SwitchedVlan) SetInterfaceMode(v E_VlanTypes_VlanModeType) {
	t.InterfaceMode = v
}

// SetNativeVlan sets the value of the leaf NativeVlan in the Interface_Aggregation_SwitchedVlan
// struct.
func (t *Interface_Aggregation_SwitchedVlan) SetNativeVlan(v uint16) {
	t.NativeVlan = &v
}

// SetTrunkVlans sets the value of the leaf TrunkVlans in the Interface_Aggregation_SwitchedVlan
// struct.
func (t *Interface_Aggregation_SwitchedVlan) SetTrunkVlans(v []Interface_Aggregation_SwitchedVlan_TrunkVlans_Union) {
	t.TrunkVlans = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Aggregation_SwitchedVlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Aggregation_SwitchedVlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation_SwitchedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Aggregation_SwitchedVlan.
func (*Interface_Aggregation_SwitchedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Counters represents the /openconfig-interfaces/interfaces/interface/state/counters YANG schema element.
type Interface_Counters struct {
	CarrierTransitions *uint64 `path:"carrier-transitions" module:"openconfig-interfaces"`
	InBroadcastPkts    *uint64 `path:"in-broadcast-pkts" module:"openconfig-interfaces"`
	InDiscards         *uint64 `path:"in-discards" module:"openconfig-interfaces"`
	InErrors           *uint64 `path:"in-errors" module:"openconfig-interfaces"`
	InFcsErrors        *uint64 `path:"in-fcs-errors" module:"openconfig-interfaces"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-interfaces"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-interfaces"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-interfaces"`
	InUnicastPkts      *uint64 `path:"in-unicast-pkts" module:"openconfig-interfaces"`
	InUnknownProtos    *uint64 `path:"in-unknown-protos" module:"openconfig-interfaces"`
	LastClear          *uint64 `path:"last-clear" module:"openconfig-interfaces"`
	OutBroadcastPkts   *uint64 `path:"out-broadcast-pkts" module:"openconfig-interfaces"`
	OutDiscards        *uint64 `path:"out-discards" module:"openconfig-interfaces"`
	OutErrors          *uint64 `path:"out-errors" module:"openconfig-interfaces"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-interfaces"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-interfaces"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-interfaces"`
	OutUnicastPkts     *uint64 `path:"out-unicast-pkts" module:"openconfig-interfaces"`
	Resets             *uint64 `path:"resets" module:"openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Counters) IsYANGGoStruct() {}

// GetCarrierTransitions retrieves the value of the leaf CarrierTransitions from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CarrierTransitions is set, it can
// safely use t.GetCarrierTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CarrierTransitions == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetCarrierTransitions() uint64 {
	if t == nil || t.CarrierTransitions == nil {
		return 0
	}
	return *t.CarrierTransitions
}

// GetInBroadcastPkts retrieves the value of the leaf InBroadcastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBroadcastPkts is set, it can
// safely use t.GetInBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInBroadcastPkts() uint64 {
	if t == nil || t.InBroadcastPkts == nil {
		return 0
	}
	return *t.InBroadcastPkts
}

// GetInDiscards retrieves the value of the leaf InDiscards from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscards is set, it can
// safely use t.GetInDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInDiscards() uint64 {
	if t == nil || t.InDiscards == nil {
		return 0
	}
	return *t.InDiscards
}

// GetInErrors retrieves the value of the leaf InErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrors is set, it can
// safely use t.GetInErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInErrors() uint64 {
	if t == nil || t.InErrors == nil {
		return 0
	}
	return *t.InErrors
}

// GetInFcsErrors retrieves the value of the leaf InFcsErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFcsErrors is set, it can
// safely use t.GetInFcsErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFcsErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInFcsErrors() uint64 {
	if t == nil || t.InFcsErrors == nil {
		return 0
	}
	return *t.InFcsErrors
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInUnicastPkts retrieves the value of the leaf InUnicastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnicastPkts is set, it can
// safely use t.GetInUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInUnicastPkts() uint64 {
	if t == nil || t.InUnicastPkts == nil {
		return 0
	}
	return *t.InUnicastPkts
}

// GetInUnknownProtos retrieves the value of the leaf InUnknownProtos from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnknownProtos is set, it can
// safely use t.GetInUnknownProtos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnknownProtos == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInUnknownProtos() uint64 {
	if t == nil || t.InUnknownProtos == nil {
		return 0
	}
	return *t.InUnknownProtos
}

// GetLastClear retrieves the value of the leaf LastClear from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetOutBroadcastPkts retrieves the value of the leaf OutBroadcastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBroadcastPkts is set, it can
// safely use t.GetOutBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutBroadcastPkts() uint64 {
	if t == nil || t.OutBroadcastPkts == nil {
		return 0
	}
	return *t.OutBroadcastPkts
}

// GetOutDiscards retrieves the value of the leaf OutDiscards from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscards is set, it can
// safely use t.GetOutDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutDiscards() uint64 {
	if t == nil || t.OutDiscards == nil {
		return 0
	}
	return *t.OutDiscards
}

// GetOutErrors retrieves the value of the leaf OutErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrors is set, it can
// safely use t.GetOutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutErrors() uint64 {
	if t == nil || t.OutErrors == nil {
		return 0
	}
	return *t.OutErrors
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// GetOutUnicastPkts retrieves the value of the leaf OutUnicastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUnicastPkts is set, it can
// safely use t.GetOutUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutUnicastPkts() uint64 {
	if t == nil || t.OutUnicastPkts == nil {
		return 0
	}
	return *t.OutUnicastPkts
}

// GetResets retrieves the value of the leaf Resets from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Resets is set, it can
// safely use t.GetResets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Resets == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetResets() uint64 {
	if t == nil || t.Resets == nil {
		return 0
	}
	return *t.Resets
}

// SetCarrierTransitions sets the value of the leaf CarrierTransitions in the Interface_Counters
// struct.
func (t *Interface_Counters) SetCarrierTransitions(v uint64) {
	t.CarrierTransitions = &v
}

// SetInBroadcastPkts sets the value of the leaf InBroadcastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInBroadcastPkts(v uint64) {
	t.InBroadcastPkts = &v
}

// SetInDiscards sets the value of the leaf InDiscards in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInDiscards(v uint64) {
	t.InDiscards = &v
}

// SetInErrors sets the value of the leaf InErrors in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInErrors(v uint64) {
	t.InErrors = &v
}

// SetInFcsErrors sets the value of the leaf InFcsErrors in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInFcsErrors(v uint64) {
	t.InFcsErrors = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetInUnicastPkts sets the value of the leaf InUnicastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInUnicastPkts(v uint64) {
	t.InUnicastPkts = &v
}

// SetInUnknownProtos sets the value of the leaf InUnknownProtos in the Interface_Counters
// struct.
func (t *Interface_Counters) SetInUnknownProtos(v uint64) {
	t.InUnknownProtos = &v
}

// SetLastClear sets the value of the leaf LastClear in the Interface_Counters
// struct.
func (t *Interface_Counters) SetLastClear(v uint64) {
	t.LastClear = &v
}

// SetOutBroadcastPkts sets the value of the leaf OutBroadcastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutBroadcastPkts(v uint64) {
	t.OutBroadcastPkts = &v
}

// SetOutDiscards sets the value of the leaf OutDiscards in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutDiscards(v uint64) {
	t.OutDiscards = &v
}

// SetOutErrors sets the value of the leaf OutErrors in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutErrors(v uint64) {
	t.OutErrors = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// SetOutUnicastPkts sets the value of the leaf OutUnicastPkts in the Interface_Counters
// struct.
func (t *Interface_Counters) SetOutUnicastPkts(v uint64) {
	t.OutUnicastPkts = &v
}

// SetResets sets the value of the leaf Resets in the Interface_Counters
// struct.
func (t *Interface_Counters) SetResets(v uint64) {
	t.Resets = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Counters.
func (*Interface_Counters) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Ethernet represents the /openconfig-interfaces/interfaces/interface/ethernet YANG schema element.
type Interface_Ethernet struct {
	AggregateId            *string                          `path:"config/aggregate-id" module:"openconfig-if-ethernet/openconfig-if-aggregate" shadow-path:"state/aggregate-id" shadow-module:"openconfig-if-ethernet/openconfig-if-aggregate"`
	AutoNegotiate          *bool                            `path:"config/auto-negotiate" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/auto-negotiate" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	Counters               *Interface_Ethernet_Counters     `path:"state/counters" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	DuplexMode             E_Ethernet_DuplexMode            `path:"config/duplex-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/duplex-mode" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	EnableFlowControl      *bool                            `path:"config/enable-flow-control" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/enable-flow-control" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	FecMode                E_IfEthernet_INTERFACE_FEC       `path:"config/fec-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/fec-mode" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	HwMacAddress           *string                          `path:"state/hw-mac-address" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	MacAddress             *string                          `path:"config/mac-address" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/mac-address" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	NegotiatedDuplexMode   E_Ethernet_NegotiatedDuplexMode  `path:"state/negotiated-duplex-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	NegotiatedPortSpeed    E_IfEthernet_ETHERNET_SPEED      `path:"state/negotiated-port-speed" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	PortSpeed              E_IfEthernet_ETHERNET_SPEED      `path:"config/port-speed" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/port-speed" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	StandaloneLinkTraining *bool                            `path:"config/standalone-link-training" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/standalone-link-training" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	SwitchedVlan           *Interface_Ethernet_SwitchedVlan `path:"switched-vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Ethernet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateCounters() *Interface_Ethernet_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Ethernet_Counters{}
	return t.Counters
}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Ethernet_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Ethernet. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetCounters() *Interface_Ethernet_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Ethernet. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// GetAggregateId retrieves the value of the leaf AggregateId from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AggregateId is set, it can
// safely use t.GetAggregateId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AggregateId == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetAggregateId() string {
	if t == nil || t.AggregateId == nil {
		return ""
	}
	return *t.AggregateId
}

// GetAutoNegotiate retrieves the value of the leaf AutoNegotiate from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoNegotiate is set, it can
// safely use t.GetAutoNegotiate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoNegotiate == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetAutoNegotiate() bool {
	if t == nil || t.AutoNegotiate == nil {
		return true
	}
	return *t.AutoNegotiate
}

// GetDuplexMode retrieves the value of the leaf DuplexMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplexMode is set, it can
// safely use t.GetDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplexMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetDuplexMode() E_Ethernet_DuplexMode {
	if t == nil || t.DuplexMode == 0 {
		return 0
	}
	return t.DuplexMode
}

// GetEnableFlowControl retrieves the value of the leaf EnableFlowControl from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableFlowControl is set, it can
// safely use t.GetEnableFlowControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableFlowControl == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetEnableFlowControl() bool {
	if t == nil || t.EnableFlowControl == nil {
		return false
	}
	return *t.EnableFlowControl
}

// GetFecMode retrieves the value of the leaf FecMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FecMode is set, it can
// safely use t.GetFecMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FecMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetFecMode() E_IfEthernet_INTERFACE_FEC {
	if t == nil || t.FecMode == 0 {
		return 0
	}
	return t.FecMode
}

// GetHwMacAddress retrieves the value of the leaf HwMacAddress from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HwMacAddress is set, it can
// safely use t.GetHwMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HwMacAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetHwMacAddress() string {
	if t == nil || t.HwMacAddress == nil {
		return ""
	}
	return *t.HwMacAddress
}

// GetMacAddress retrieves the value of the leaf MacAddress from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNegotiatedDuplexMode retrieves the value of the leaf NegotiatedDuplexMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NegotiatedDuplexMode is set, it can
// safely use t.GetNegotiatedDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NegotiatedDuplexMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetNegotiatedDuplexMode() E_Ethernet_NegotiatedDuplexMode {
	if t == nil || t.NegotiatedDuplexMode == 0 {
		return 0
	}
	return t.NegotiatedDuplexMode
}

// GetNegotiatedPortSpeed retrieves the value of the leaf NegotiatedPortSpeed from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NegotiatedPortSpeed is set, it can
// safely use t.GetNegotiatedPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NegotiatedPortSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetNegotiatedPortSpeed() E_IfEthernet_ETHERNET_SPEED {
	if t == nil || t.NegotiatedPortSpeed == 0 {
		return 0
	}
	return t.NegotiatedPortSpeed
}

// GetPortSpeed retrieves the value of the leaf PortSpeed from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSpeed is set, it can
// safely use t.GetPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetPortSpeed() E_IfEthernet_ETHERNET_SPEED {
	if t == nil || t.PortSpeed == 0 {
		return 0
	}
	return t.PortSpeed
}

// GetStandaloneLinkTraining retrieves the value of the leaf StandaloneLinkTraining from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StandaloneLinkTraining is set, it can
// safely use t.GetStandaloneLinkTraining() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StandaloneLinkTraining == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetStandaloneLinkTraining() bool {
	if t == nil || t.StandaloneLinkTraining == nil {
		return false
	}
	return *t.StandaloneLinkTraining
}

// SetAggregateId sets the value of the leaf AggregateId in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetAggregateId(v string) {
	t.AggregateId = &v
}

// SetAutoNegotiate sets the value of the leaf AutoNegotiate in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetAutoNegotiate(v bool) {
	t.AutoNegotiate = &v
}

// SetDuplexMode sets the value of the leaf DuplexMode in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetDuplexMode(v E_Ethernet_DuplexMode) {
	t.DuplexMode = v
}

// SetEnableFlowControl sets the value of the leaf EnableFlowControl in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetEnableFlowControl(v bool) {
	t.EnableFlowControl = &v
}

// SetFecMode sets the value of the leaf FecMode in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetFecMode(v E_IfEthernet_INTERFACE_FEC) {
	t.FecMode = v
}

// SetHwMacAddress sets the value of the leaf HwMacAddress in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetHwMacAddress(v string) {
	t.HwMacAddress = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetNegotiatedDuplexMode sets the value of the leaf NegotiatedDuplexMode in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetNegotiatedDuplexMode(v E_Ethernet_NegotiatedDuplexMode) {
	t.NegotiatedDuplexMode = v
}

// SetNegotiatedPortSpeed sets the value of the leaf NegotiatedPortSpeed in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetNegotiatedPortSpeed(v E_IfEthernet_ETHERNET_SPEED) {
	t.NegotiatedPortSpeed = v
}

// SetPortSpeed sets the value of the leaf PortSpeed in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetPortSpeed(v E_IfEthernet_ETHERNET_SPEED) {
	t.PortSpeed = v
}

// SetStandaloneLinkTraining sets the value of the leaf StandaloneLinkTraining in the Interface_Ethernet
// struct.
func (t *Interface_Ethernet) SetStandaloneLinkTraining(v bool) {
	t.StandaloneLinkTraining = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ethernet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ethernet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AutoNegotiate == nil {
		var v bool = true
		t.AutoNegotiate = &v
	}
	if t.EnableFlowControl == nil {
		var v bool = false
		t.EnableFlowControl = &v
	}
	if t.StandaloneLinkTraining == nil {
		var v bool = false
		t.StandaloneLinkTraining = &v
	}
	t.Counters.PopulateDefaults()
	t.SwitchedVlan.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet.
func (*Interface_Ethernet) ΛBelongingModule() string {
	return "openconfig-if-ethernet"
}

// Interface_Ethernet_Counters represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters YANG schema element.
type Interface_Ethernet_Counters struct {
	In_8021QFrames      *uint64 `path:"in-8021q-frames" module:"openconfig-if-ethernet"`
	InBlockErrors       *uint64 `path:"in-block-errors" module:"openconfig-if-ethernet"`
	InCarrierErrors     *uint64 `path:"in-carrier-errors" module:"openconfig-if-ethernet"`
	InCrcErrors         *uint64 `path:"in-crc-errors" module:"openconfig-if-ethernet"`
	InFragmentFrames    *uint64 `path:"in-fragment-frames" module:"openconfig-if-ethernet"`
	InInterruptedTx     *uint64 `path:"in-interrupted-tx" module:"openconfig-if-ethernet"`
	InJabberFrames      *uint64 `path:"in-jabber-frames" module:"openconfig-if-ethernet"`
	InLateCollision     *uint64 `path:"in-late-collision" module:"openconfig-if-ethernet"`
	InMacControlFrames  *uint64 `path:"in-mac-control-frames" module:"openconfig-if-ethernet"`
	InMacErrorsRx       *uint64 `path:"in-mac-errors-rx" module:"openconfig-if-ethernet"`
	InMacPauseFrames    *uint64 `path:"in-mac-pause-frames" module:"openconfig-if-ethernet"`
	InMaxsizeExceeded   *uint64 `path:"in-maxsize-exceeded" module:"openconfig-if-ethernet"`
	InOversizeFrames    *uint64 `path:"in-oversize-frames" module:"openconfig-if-ethernet"`
	InSingleCollision   *uint64 `path:"in-single-collision" module:"openconfig-if-ethernet"`
	InSymbolError       *uint64 `path:"in-symbol-error" module:"openconfig-if-ethernet"`
	InUndersizeFrames   *uint64 `path:"in-undersize-frames" module:"openconfig-if-ethernet"`
	Out_8021QFrames     *uint64 `path:"out-8021q-frames" module:"openconfig-if-ethernet"`
	OutMacControlFrames *uint64 `path:"out-mac-control-frames" module:"openconfig-if-ethernet"`
	OutMacErrorsTx      *uint64 `path:"out-mac-errors-tx" module:"openconfig-if-ethernet"`
	OutMacPauseFrames   *uint64 `path:"out-mac-pause-frames" module:"openconfig-if-ethernet"`
}

// IsYANGGoStruct ensures that Interface_Ethernet_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet_Counters) IsYANGGoStruct() {}

// GetIn_8021QFrames retrieves the value of the leaf In_8021QFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if In_8021QFrames is set, it can
// safely use t.GetIn_8021QFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.In_8021QFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetIn_8021QFrames() uint64 {
	if t == nil || t.In_8021QFrames == nil {
		return 0
	}
	return *t.In_8021QFrames
}

// GetInBlockErrors retrieves the value of the leaf InBlockErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBlockErrors is set, it can
// safely use t.GetInBlockErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBlockErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInBlockErrors() uint64 {
	if t == nil || t.InBlockErrors == nil {
		return 0
	}
	return *t.InBlockErrors
}

// GetInCarrierErrors retrieves the value of the leaf InCarrierErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCarrierErrors is set, it can
// safely use t.GetInCarrierErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCarrierErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInCarrierErrors() uint64 {
	if t == nil || t.InCarrierErrors == nil {
		return 0
	}
	return *t.InCarrierErrors
}

// GetInCrcErrors retrieves the value of the leaf InCrcErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCrcErrors is set, it can
// safely use t.GetInCrcErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCrcErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInCrcErrors() uint64 {
	if t == nil || t.InCrcErrors == nil {
		return 0
	}
	return *t.InCrcErrors
}

// GetInFragmentFrames retrieves the value of the leaf InFragmentFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFragmentFrames is set, it can
// safely use t.GetInFragmentFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFragmentFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInFragmentFrames() uint64 {
	if t == nil || t.InFragmentFrames == nil {
		return 0
	}
	return *t.InFragmentFrames
}

// GetInInterruptedTx retrieves the value of the leaf InInterruptedTx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InInterruptedTx is set, it can
// safely use t.GetInInterruptedTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InInterruptedTx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInInterruptedTx() uint64 {
	if t == nil || t.InInterruptedTx == nil {
		return 0
	}
	return *t.InInterruptedTx
}

// GetInJabberFrames retrieves the value of the leaf InJabberFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InJabberFrames is set, it can
// safely use t.GetInJabberFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InJabberFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInJabberFrames() uint64 {
	if t == nil || t.InJabberFrames == nil {
		return 0
	}
	return *t.InJabberFrames
}

// GetInLateCollision retrieves the value of the leaf InLateCollision from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InLateCollision is set, it can
// safely use t.GetInLateCollision() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InLateCollision == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInLateCollision() uint64 {
	if t == nil || t.InLateCollision == nil {
		return 0
	}
	return *t.InLateCollision
}

// GetInMacControlFrames retrieves the value of the leaf InMacControlFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacControlFrames is set, it can
// safely use t.GetInMacControlFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacControlFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacControlFrames() uint64 {
	if t == nil || t.InMacControlFrames == nil {
		return 0
	}
	return *t.InMacControlFrames
}

// GetInMacErrorsRx retrieves the value of the leaf InMacErrorsRx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacErrorsRx is set, it can
// safely use t.GetInMacErrorsRx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacErrorsRx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacErrorsRx() uint64 {
	if t == nil || t.InMacErrorsRx == nil {
		return 0
	}
	return *t.InMacErrorsRx
}

// GetInMacPauseFrames retrieves the value of the leaf InMacPauseFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacPauseFrames is set, it can
// safely use t.GetInMacPauseFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacPauseFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacPauseFrames() uint64 {
	if t == nil || t.InMacPauseFrames == nil {
		return 0
	}
	return *t.InMacPauseFrames
}

// GetInMaxsizeExceeded retrieves the value of the leaf InMaxsizeExceeded from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMaxsizeExceeded is set, it can
// safely use t.GetInMaxsizeExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMaxsizeExceeded == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMaxsizeExceeded() uint64 {
	if t == nil || t.InMaxsizeExceeded == nil {
		return 0
	}
	return *t.InMaxsizeExceeded
}

// GetInOversizeFrames retrieves the value of the leaf InOversizeFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOversizeFrames is set, it can
// safely use t.GetInOversizeFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOversizeFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInOversizeFrames() uint64 {
	if t == nil || t.InOversizeFrames == nil {
		return 0
	}
	return *t.InOversizeFrames
}

// GetInSingleCollision retrieves the value of the leaf InSingleCollision from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSingleCollision is set, it can
// safely use t.GetInSingleCollision() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSingleCollision == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInSingleCollision() uint64 {
	if t == nil || t.InSingleCollision == nil {
		return 0
	}
	return *t.InSingleCollision
}

// GetInSymbolError retrieves the value of the leaf InSymbolError from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSymbolError is set, it can
// safely use t.GetInSymbolError() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSymbolError == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInSymbolError() uint64 {
	if t == nil || t.InSymbolError == nil {
		return 0
	}
	return *t.InSymbolError
}

// GetInUndersizeFrames retrieves the value of the leaf InUndersizeFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUndersizeFrames is set, it can
// safely use t.GetInUndersizeFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUndersizeFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInUndersizeFrames() uint64 {
	if t == nil || t.InUndersizeFrames == nil {
		return 0
	}
	return *t.InUndersizeFrames
}

// GetOut_8021QFrames retrieves the value of the leaf Out_8021QFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Out_8021QFrames is set, it can
// safely use t.GetOut_8021QFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Out_8021QFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOut_8021QFrames() uint64 {
	if t == nil || t.Out_8021QFrames == nil {
		return 0
	}
	return *t.Out_8021QFrames
}

// GetOutMacControlFrames retrieves the value of the leaf OutMacControlFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacControlFrames is set, it can
// safely use t.GetOutMacControlFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacControlFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacControlFrames() uint64 {
	if t == nil || t.OutMacControlFrames == nil {
		return 0
	}
	return *t.OutMacControlFrames
}

// GetOutMacErrorsTx retrieves the value of the leaf OutMacErrorsTx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacErrorsTx is set, it can
// safely use t.GetOutMacErrorsTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacErrorsTx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacErrorsTx() uint64 {
	if t == nil || t.OutMacErrorsTx == nil {
		return 0
	}
	return *t.OutMacErrorsTx
}

// GetOutMacPauseFrames retrieves the value of the leaf OutMacPauseFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacPauseFrames is set, it can
// safely use t.GetOutMacPauseFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacPauseFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacPauseFrames() uint64 {
	if t == nil || t.OutMacPauseFrames == nil {
		return 0
	}
	return *t.OutMacPauseFrames
}

// SetIn_8021QFrames sets the value of the leaf In_8021QFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetIn_8021QFrames(v uint64) {
	t.In_8021QFrames = &v
}

// SetInBlockErrors sets the value of the leaf InBlockErrors in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInBlockErrors(v uint64) {
	t.InBlockErrors = &v
}

// SetInCarrierErrors sets the value of the leaf InCarrierErrors in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInCarrierErrors(v uint64) {
	t.InCarrierErrors = &v
}

// SetInCrcErrors sets the value of the leaf InCrcErrors in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInCrcErrors(v uint64) {
	t.InCrcErrors = &v
}

// SetInFragmentFrames sets the value of the leaf InFragmentFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInFragmentFrames(v uint64) {
	t.InFragmentFrames = &v
}

// SetInInterruptedTx sets the value of the leaf InInterruptedTx in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInInterruptedTx(v uint64) {
	t.InInterruptedTx = &v
}

// SetInJabberFrames sets the value of the leaf InJabberFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInJabberFrames(v uint64) {
	t.InJabberFrames = &v
}

// SetInLateCollision sets the value of the leaf InLateCollision in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInLateCollision(v uint64) {
	t.InLateCollision = &v
}

// SetInMacControlFrames sets the value of the leaf InMacControlFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInMacControlFrames(v uint64) {
	t.InMacControlFrames = &v
}

// SetInMacErrorsRx sets the value of the leaf InMacErrorsRx in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInMacErrorsRx(v uint64) {
	t.InMacErrorsRx = &v
}

// SetInMacPauseFrames sets the value of the leaf InMacPauseFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInMacPauseFrames(v uint64) {
	t.InMacPauseFrames = &v
}

// SetInMaxsizeExceeded sets the value of the leaf InMaxsizeExceeded in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInMaxsizeExceeded(v uint64) {
	t.InMaxsizeExceeded = &v
}

// SetInOversizeFrames sets the value of the leaf InOversizeFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInOversizeFrames(v uint64) {
	t.InOversizeFrames = &v
}

// SetInSingleCollision sets the value of the leaf InSingleCollision in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInSingleCollision(v uint64) {
	t.InSingleCollision = &v
}

// SetInSymbolError sets the value of the leaf InSymbolError in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInSymbolError(v uint64) {
	t.InSymbolError = &v
}

// SetInUndersizeFrames sets the value of the leaf InUndersizeFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetInUndersizeFrames(v uint64) {
	t.InUndersizeFrames = &v
}

// SetOut_8021QFrames sets the value of the leaf Out_8021QFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetOut_8021QFrames(v uint64) {
	t.Out_8021QFrames = &v
}

// SetOutMacControlFrames sets the value of the leaf OutMacControlFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetOutMacControlFrames(v uint64) {
	t.OutMacControlFrames = &v
}

// SetOutMacErrorsTx sets the value of the leaf OutMacErrorsTx in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetOutMacErrorsTx(v uint64) {
	t.OutMacErrorsTx = &v
}

// SetOutMacPauseFrames sets the value of the leaf OutMacPauseFrames in the Interface_Ethernet_Counters
// struct.
func (t *Interface_Ethernet_Counters) SetOutMacPauseFrames(v uint64) {
	t.OutMacPauseFrames = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ethernet_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ethernet_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet_Counters.
func (*Interface_Ethernet_Counters) ΛBelongingModule() string {
	return "openconfig-if-ethernet"
}

// Interface_Ethernet_SwitchedVlan represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan struct {
	AccessVlan    *uint16                                            `path:"config/access-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/access-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InterfaceMode E_VlanTypes_VlanModeType                           `path:"config/interface-mode" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/interface-mode" shadow-module:"openconfig-vlan/openconfig-vlan"`
	NativeVlan    *uint16                                            `path:"config/native-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/native-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	TrunkVlans    []Interface_Ethernet_SwitchedVlan_TrunkVlans_Union `path:"config/trunk-vlans" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/trunk-vlans" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Ethernet_SwitchedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet_SwitchedVlan) IsYANGGoStruct() {}

// GetAccessVlan retrieves the value of the leaf AccessVlan from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccessVlan is set, it can
// safely use t.GetAccessVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccessVlan == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetAccessVlan() uint16 {
	if t == nil || t.AccessVlan == nil {
		return 0
	}
	return *t.AccessVlan
}

// GetInterfaceMode retrieves the value of the leaf InterfaceMode from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceMode is set, it can
// safely use t.GetInterfaceMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetInterfaceMode() E_VlanTypes_VlanModeType {
	if t == nil || t.InterfaceMode == 0 {
		return 0
	}
	return t.InterfaceMode
}

// GetNativeVlan retrieves the value of the leaf NativeVlan from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NativeVlan is set, it can
// safely use t.GetNativeVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NativeVlan == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetNativeVlan() uint16 {
	if t == nil || t.NativeVlan == nil {
		return 0
	}
	return *t.NativeVlan
}

// GetTrunkVlans retrieves the value of the leaf TrunkVlans from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrunkVlans is set, it can
// safely use t.GetTrunkVlans() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrunkVlans == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetTrunkVlans() []Interface_Ethernet_SwitchedVlan_TrunkVlans_Union {
	if t == nil || t.TrunkVlans == nil {
		return nil
	}
	return t.TrunkVlans
}

// SetAccessVlan sets the value of the leaf AccessVlan in the Interface_Ethernet_SwitchedVlan
// struct.
func (t *Interface_Ethernet_SwitchedVlan) SetAccessVlan(v uint16) {
	t.AccessVlan = &v
}

// SetInterfaceMode sets the value of the leaf InterfaceMode in the Interface_Ethernet_SwitchedVlan
// struct.
func (t *Interface_Ethernet_SwitchedVlan) SetInterfaceMode(v E_VlanTypes_VlanModeType) {
	t.InterfaceMode = v
}

// SetNativeVlan sets the value of the leaf NativeVlan in the Interface_Ethernet_SwitchedVlan
// struct.
func (t *Interface_Ethernet_SwitchedVlan) SetNativeVlan(v uint16) {
	t.NativeVlan = &v
}

// SetTrunkVlans sets the value of the leaf TrunkVlans in the Interface_Ethernet_SwitchedVlan
// struct.
func (t *Interface_Ethernet_SwitchedVlan) SetTrunkVlans(v []Interface_Ethernet_SwitchedVlan_TrunkVlans_Union) {
	t.TrunkVlans = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ethernet_SwitchedVlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ethernet_SwitchedVlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_SwitchedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet_SwitchedVlan.
func (*Interface_Ethernet_SwitchedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_HoldTime represents the /openconfig-interfaces/interfaces/interface/hold-time YANG schema element.
type Interface_HoldTime struct {
	Down *uint32 `path:"config/down" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/down" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Up   *uint32 `path:"config/up" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/up" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_HoldTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_HoldTime) IsYANGGoStruct() {}

// GetDown retrieves the value of the leaf Down from the Interface_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Down is set, it can
// safely use t.GetDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Down == nil' before retrieving the leaf's value.
func (t *Interface_HoldTime) GetDown() uint32 {
	if t == nil || t.Down == nil {
		return 0
	}
	return *t.Down
}

// GetUp retrieves the value of the leaf Up from the Interface_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Up is set, it can
// safely use t.GetUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Up == nil' before retrieving the leaf's value.
func (t *Interface_HoldTime) GetUp() uint32 {
	if t == nil || t.Up == nil {
		return 0
	}
	return *t.Up
}

// SetDown sets the value of the leaf Down in the Interface_HoldTime
// struct.
func (t *Interface_HoldTime) SetDown(v uint32) {
	t.Down = &v
}

// SetUp sets the value of the leaf Up in the Interface_HoldTime
// struct.
func (t *Interface_HoldTime) SetUp(v uint32) {
	t.Up = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_HoldTime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_HoldTime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Down == nil {
		var v uint32 = 0
		t.Down = &v
	}
	if t.Up == nil {
		var v uint32 = 0
		t.Up = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_HoldTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_HoldTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_HoldTime.
func (*Interface_HoldTime) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_PenaltyBasedAied represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied YANG schema element.
type Interface_PenaltyBasedAied struct {
	DecayHalfLife     *uint32 `path:"config/decay-half-life" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/decay-half-life" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	FlapPenalty       *uint32 `path:"config/flap-penalty" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/flap-penalty" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	MaxSuppressTime   *uint32 `path:"config/max-suppress-time" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/max-suppress-time" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	ReuseThreshold    *uint32 `path:"config/reuse-threshold" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/reuse-threshold" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	SuppressThreshold *uint32 `path:"config/suppress-threshold" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/suppress-threshold" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_PenaltyBasedAied implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_PenaltyBasedAied) IsYANGGoStruct() {}

// GetDecayHalfLife retrieves the value of the leaf DecayHalfLife from the Interface_PenaltyBasedAied
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecayHalfLife is set, it can
// safely use t.GetDecayHalfLife() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecayHalfLife == nil' before retrieving the leaf's value.
func (t *Interface_PenaltyBasedAied) GetDecayHalfLife() uint32 {
	if t == nil || t.DecayHalfLife == nil {
		return 0
	}
	return *t.DecayHalfLife
}

// GetFlapPenalty retrieves the value of the leaf FlapPenalty from the Interface_PenaltyBasedAied
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlapPenalty is set, it can
// safely use t.GetFlapPenalty() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlapPenalty == nil' before retrieving the leaf's value.
func (t *Interface_PenaltyBasedAied) GetFlapPenalty() uint32 {
	if t == nil || t.FlapPenalty == nil {
		return 0
	}
	return *t.FlapPenalty
}

// GetMaxSuppressTime retrieves the value of the leaf MaxSuppressTime from the Interface_PenaltyBasedAied
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxSuppressTime is set, it can
// safely use t.GetMaxSuppressTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxSuppressTime == nil' before retrieving the leaf's value.
func (t *Interface_PenaltyBasedAied) GetMaxSuppressTime() uint32 {
	if t == nil || t.MaxSuppressTime == nil {
		return 0
	}
	return *t.MaxSuppressTime
}

// GetReuseThreshold retrieves the value of the leaf ReuseThreshold from the Interface_PenaltyBasedAied
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReuseThreshold is set, it can
// safely use t.GetReuseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReuseThreshold == nil' before retrieving the leaf's value.
func (t *Interface_PenaltyBasedAied) GetReuseThreshold() uint32 {
	if t == nil || t.ReuseThreshold == nil {
		return 0
	}
	return *t.ReuseThreshold
}

// GetSuppressThreshold retrieves the value of the leaf SuppressThreshold from the Interface_PenaltyBasedAied
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressThreshold is set, it can
// safely use t.GetSuppressThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressThreshold == nil' before retrieving the leaf's value.
func (t *Interface_PenaltyBasedAied) GetSuppressThreshold() uint32 {
	if t == nil || t.SuppressThreshold == nil {
		return 0
	}
	return *t.SuppressThreshold
}

// SetDecayHalfLife sets the value of the leaf DecayHalfLife in the Interface_PenaltyBasedAied
// struct.
func (t *Interface_PenaltyBasedAied) SetDecayHalfLife(v uint32) {
	t.DecayHalfLife = &v
}

// SetFlapPenalty sets the value of the leaf FlapPenalty in the Interface_PenaltyBasedAied
// struct.
func (t *Interface_PenaltyBasedAied) SetFlapPenalty(v uint32) {
	t.FlapPenalty = &v
}

// SetMaxSuppressTime sets the value of the leaf MaxSuppressTime in the Interface_PenaltyBasedAied
// struct.
func (t *Interface_PenaltyBasedAied) SetMaxSuppressTime(v uint32) {
	t.MaxSuppressTime = &v
}

// SetReuseThreshold sets the value of the leaf ReuseThreshold in the Interface_PenaltyBasedAied
// struct.
func (t *Interface_PenaltyBasedAied) SetReuseThreshold(v uint32) {
	t.ReuseThreshold = &v
}

// SetSuppressThreshold sets the value of the leaf SuppressThreshold in the Interface_PenaltyBasedAied
// struct.
func (t *Interface_PenaltyBasedAied) SetSuppressThreshold(v uint32) {
	t.SuppressThreshold = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_PenaltyBasedAied
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_PenaltyBasedAied) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DecayHalfLife == nil {
		var v uint32 = 0
		t.DecayHalfLife = &v
	}
	if t.FlapPenalty == nil {
		var v uint32 = 0
		t.FlapPenalty = &v
	}
	if t.MaxSuppressTime == nil {
		var v uint32 = 0
		t.MaxSuppressTime = &v
	}
	if t.ReuseThreshold == nil {
		var v uint32 = 0
		t.ReuseThreshold = &v
	}
	if t.SuppressThreshold == nil {
		var v uint32 = 0
		t.SuppressThreshold = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_PenaltyBasedAied) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_PenaltyBasedAied"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_PenaltyBasedAied) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_PenaltyBasedAied) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_PenaltyBasedAied.
func (*Interface_PenaltyBasedAied) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_RoutedVlan represents the /openconfig-interfaces/interfaces/interface/routed-vlan YANG schema element.
type Interface_RoutedVlan struct {
	Ipv4 *Interface_RoutedVlan_Ipv4      `path:"ipv4" module:"openconfig-if-ip"`
	Ipv6 *Interface_RoutedVlan_Ipv6      `path:"ipv6" module:"openconfig-if-ip"`
	Vlan Interface_RoutedVlan_Vlan_Union `path:"config/vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv4() *Interface_RoutedVlan_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_RoutedVlan_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv6() *Interface_RoutedVlan_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_RoutedVlan_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv4() *Interface_RoutedVlan_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv6() *Interface_RoutedVlan_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan retrieves the value of the leaf Vlan from the Interface_RoutedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan) GetVlan() Interface_RoutedVlan_Vlan_Union {
	if t == nil || t.Vlan == nil {
		return nil
	}
	return t.Vlan
}

// SetVlan sets the value of the leaf Vlan in the Interface_RoutedVlan
// struct.
func (t *Interface_RoutedVlan) SetVlan(v Interface_RoutedVlan_Vlan_Union) {
	t.Vlan = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan.
func (*Interface_RoutedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_RoutedVlan_Ipv4 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4 YANG schema element.
type Interface_RoutedVlan_Ipv4 struct {
	Address               map[string]*Interface_RoutedVlan_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters              *Interface_RoutedVlan_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient            *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled               *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	GratuitousArpAccepted *bool                                          `path:"config/gratuitous-arp-accepted" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/gratuitous-arp-accepted" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                   *uint16                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor              map[string]*Interface_RoutedVlan_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ProxyArp              *Interface_RoutedVlan_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	Unnumbered            *Interface_RoutedVlan_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddressMap returns the list (map) from Interface_RoutedVlan_Ipv4.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddressMap() map[string]*Interface_RoutedVlan_Ipv4_Address {
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}
	return t.Address
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv4_Address struct to the
// list Address of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendAddress(v *Interface_RoutedVlan_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from Interface_RoutedVlan_Ipv4.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighborMap() map[string]*Interface_RoutedVlan_Ipv4_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv4_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendNeighbor(v *Interface_RoutedVlan_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_RoutedVlan_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetGratuitousArpAccepted retrieves the value of the leaf GratuitousArpAccepted from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GratuitousArpAccepted is set, it can
// safely use t.GetGratuitousArpAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GratuitousArpAccepted == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetGratuitousArpAccepted() bool {
	if t == nil || t.GratuitousArpAccepted == nil {
		return false
	}
	return *t.GratuitousArpAccepted
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// SetDhcpClient sets the value of the leaf DhcpClient in the Interface_RoutedVlan_Ipv4
// struct.
func (t *Interface_RoutedVlan_Ipv4) SetDhcpClient(v bool) {
	t.DhcpClient = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface_RoutedVlan_Ipv4
// struct.
func (t *Interface_RoutedVlan_Ipv4) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetGratuitousArpAccepted sets the value of the leaf GratuitousArpAccepted in the Interface_RoutedVlan_Ipv4
// struct.
func (t *Interface_RoutedVlan_Ipv4) SetGratuitousArpAccepted(v bool) {
	t.GratuitousArpAccepted = &v
}

// SetMtu sets the value of the leaf Mtu in the Interface_RoutedVlan_Ipv4
// struct.
func (t *Interface_RoutedVlan_Ipv4) SetMtu(v uint16) {
	t.Mtu = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	t.ProxyArp.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4.
func (*Interface_RoutedVlan_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv4_Address struct {
	Ip           *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Type         E_IfIp_Ipv4AddressType                                 `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/type" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroupMap returns the list (map) from Interface_RoutedVlan_Ipv4_Address.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroupMap() map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup {
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}
	return t.VrrpGroup
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetType retrieves the value of the leaf Type from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetType() E_IfIp_Ipv4AddressType {
	if t == nil || t.Type == 0 {
		return IfIp_Ipv4AddressType_PRIMARY
	}
	return t.Type
}

// SetIp sets the value of the leaf Ip in the Interface_RoutedVlan_Ipv4_Address
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address) SetIp(v string) {
	t.Ip = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_RoutedVlan_Ipv4_Address
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address) SetOrigin(v E_IfIp_IpAddressOrigin) {
	t.Origin = v
}

// SetPrefixLength sets the value of the leaf PrefixLength in the Interface_RoutedVlan_Ipv4_Address
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address) SetPrefixLength(v uint8) {
	t.PrefixLength = &v
}

// SetType sets the value of the leaf Type in the Interface_RoutedVlan_Ipv4_Address
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address) SetType(v E_IfIp_Ipv4AddressType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = IfIp_Ipv4AddressType_PRIMARY
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address.
func (*Interface_RoutedVlan_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct {
	AcceptMode            *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// SetAcceptMode sets the value of the leaf AcceptMode in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetAcceptMode(v bool) {
	t.AcceptMode = &v
}

// SetAdvertisementInterval sets the value of the leaf AdvertisementInterval in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetAdvertisementInterval(v uint16) {
	t.AdvertisementInterval = &v
}

// SetCurrentPriority sets the value of the leaf CurrentPriority in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetCurrentPriority(v uint8) {
	t.CurrentPriority = &v
}

// SetPreempt sets the value of the leaf Preempt in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetPreempt(v bool) {
	t.Preempt = &v
}

// SetPreemptDelay sets the value of the leaf PreemptDelay in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetPreemptDelay(v uint16) {
	t.PreemptDelay = &v
}

// SetPriority sets the value of the leaf Priority in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetPriority(v uint8) {
	t.Priority = &v
}

// SetVirtualAddress sets the value of the leaf VirtualAddress in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetVirtualAddress(v []string) {
	t.VirtualAddress = v
}

// SetVirtualRouterId sets the value of the leaf VirtualRouterId in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) SetVirtualRouterId(v uint8) {
	t.VirtualRouterId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// SetPriorityDecrement sets the value of the leaf PriorityDecrement in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) SetPriorityDecrement(v uint8) {
	t.PriorityDecrement = &v
}

// SetTrackInterface sets the value of the leaf TrackInterface in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) SetTrackInterface(v []string) {
	t.TrackInterface = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv4_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InMulticastOctets  *uint64 `path:"in-multicast-octets" module:"openconfig-if-ip"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutMulticastOctets *uint64 `path:"out-multicast-octets" module:"openconfig-if-ip"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// SetInDiscardedPkts sets the value of the leaf InDiscardedPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInDiscardedPkts(v uint64) {
	t.InDiscardedPkts = &v
}

// SetInErrorPkts sets the value of the leaf InErrorPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInErrorPkts(v uint64) {
	t.InErrorPkts = &v
}

// SetInForwardedOctets sets the value of the leaf InForwardedOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInForwardedOctets(v uint64) {
	t.InForwardedOctets = &v
}

// SetInForwardedPkts sets the value of the leaf InForwardedPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInForwardedPkts(v uint64) {
	t.InForwardedPkts = &v
}

// SetInMulticastOctets sets the value of the leaf InMulticastOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInMulticastOctets(v uint64) {
	t.InMulticastOctets = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetOutDiscardedPkts sets the value of the leaf OutDiscardedPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutDiscardedPkts(v uint64) {
	t.OutDiscardedPkts = &v
}

// SetOutErrorPkts sets the value of the leaf OutErrorPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutErrorPkts(v uint64) {
	t.OutErrorPkts = &v
}

// SetOutForwardedOctets sets the value of the leaf OutForwardedOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutForwardedOctets(v uint64) {
	t.OutForwardedOctets = &v
}

// SetOutForwardedPkts sets the value of the leaf OutForwardedPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutForwardedPkts(v uint64) {
	t.OutForwardedPkts = &v
}

// SetOutMulticastOctets sets the value of the leaf OutMulticastOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutMulticastOctets(v uint64) {
	t.OutMulticastOctets = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_RoutedVlan_Ipv4_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv4_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Counters.
func (*Interface_RoutedVlan_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv4_Neighbor struct {
	Ip               *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	LinkLayerAddress *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// SetIp sets the value of the leaf Ip in the Interface_RoutedVlan_Ipv4_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) SetIp(v string) {
	t.Ip = &v
}

// SetLinkLayerAddress sets the value of the leaf LinkLayerAddress in the Interface_RoutedVlan_Ipv4_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) SetLinkLayerAddress(v string) {
	t.LinkLayerAddress = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_RoutedVlan_Ipv4_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) SetOrigin(v E_IfIp_NeighborOrigin) {
	t.Origin = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Neighbor.
func (*Interface_RoutedVlan_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/proxy-arp YANG schema element.
type Interface_RoutedVlan_Ipv4_ProxyArp struct {
	Mode E_ProxyArp_Mode `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_RoutedVlan_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) GetMode() E_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// SetMode sets the value of the leaf Mode in the Interface_RoutedVlan_Ipv4_ProxyArp
// struct.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) SetMode(v E_ProxyArp_Mode) {
	t.Mode = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_ProxyArp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = ProxyArp_Mode_DISABLE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_ProxyArp.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered struct {
	Enabled      *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// SetEnabled sets the value of the leaf Enabled in the Interface_RoutedVlan_Ipv4_Unnumbered
// struct.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) SetEnabled(v bool) {
	t.Enabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6 YANG schema element.
type Interface_RoutedVlan_Ipv6 struct {
	Address                map[string]*Interface_RoutedVlan_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters               *Interface_RoutedVlan_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient             *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DupAddrDetectTransmits *uint32                                        `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dup-addr-detect-transmits" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled                *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	LearnUnsolicited       E_Ipv6_LearnUnsolicited                        `path:"config/learn-unsolicited" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/learn-unsolicited" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                    *uint32                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor               map[string]*Interface_RoutedVlan_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	RouterAdvertisement    *Interface_RoutedVlan_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	Unnumbered             *Interface_RoutedVlan_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddressMap returns the list (map) from Interface_RoutedVlan_Ipv6.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddressMap() map[string]*Interface_RoutedVlan_Ipv6_Address {
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}
	return t.Address
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv6_Address struct to the
// list Address of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendAddress(v *Interface_RoutedVlan_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from Interface_RoutedVlan_Ipv6.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighborMap() map[string]*Interface_RoutedVlan_Ipv6_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv6_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendNeighbor(v *Interface_RoutedVlan_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_RoutedVlan_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetLearnUnsolicited retrieves the value of the leaf LearnUnsolicited from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearnUnsolicited is set, it can
// safely use t.GetLearnUnsolicited() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearnUnsolicited == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetLearnUnsolicited() E_Ipv6_LearnUnsolicited {
	if t == nil || t.LearnUnsolicited == 0 {
		return Ipv6_LearnUnsolicited_NONE
	}
	return t.LearnUnsolicited
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// SetDhcpClient sets the value of the leaf DhcpClient in the Interface_RoutedVlan_Ipv6
// struct.
func (t *Interface_RoutedVlan_Ipv6) SetDhcpClient(v bool) {
	t.DhcpClient = &v
}

// SetDupAddrDetectTransmits sets the value of the leaf DupAddrDetectTransmits in the Interface_RoutedVlan_Ipv6
// struct.
func (t *Interface_RoutedVlan_Ipv6) SetDupAddrDetectTransmits(v uint32) {
	t.DupAddrDetectTransmits = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface_RoutedVlan_Ipv6
// struct.
func (t *Interface_RoutedVlan_Ipv6) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetLearnUnsolicited sets the value of the leaf LearnUnsolicited in the Interface_RoutedVlan_Ipv6
// struct.
func (t *Interface_RoutedVlan_Ipv6) SetLearnUnsolicited(v E_Ipv6_LearnUnsolicited) {
	t.LearnUnsolicited = v
}

// SetMtu sets the value of the leaf Mtu in the Interface_RoutedVlan_Ipv6
// struct.
func (t *Interface_RoutedVlan_Ipv6) SetMtu(v uint32) {
	t.Mtu = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.DupAddrDetectTransmits == nil {
		var v uint32 = 1
		t.DupAddrDetectTransmits = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	if t.LearnUnsolicited == 0 {
		t.LearnUnsolicited = Ipv6_LearnUnsolicited_NONE
	}
	t.Counters.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6.
func (*Interface_RoutedVlan_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv6_Address struct {
	Ip           *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Status       E_Address_Status                                       `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	Type         E_InetTypes_Ipv6AddressType                            `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/type" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroupMap returns the list (map) from Interface_RoutedVlan_Ipv6_Address.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroupMap() map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup {
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}
	return t.VrrpGroup
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetStatus() E_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// GetType retrieves the value of the leaf Type from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetType() E_InetTypes_Ipv6AddressType {
	if t == nil || t.Type == 0 {
		return InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	return t.Type
}

// SetIp sets the value of the leaf Ip in the Interface_RoutedVlan_Ipv6_Address
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address) SetIp(v string) {
	t.Ip = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_RoutedVlan_Ipv6_Address
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address) SetOrigin(v E_IfIp_IpAddressOrigin) {
	t.Origin = v
}

// SetPrefixLength sets the value of the leaf PrefixLength in the Interface_RoutedVlan_Ipv6_Address
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address) SetPrefixLength(v uint8) {
	t.PrefixLength = &v
}

// SetStatus sets the value of the leaf Status in the Interface_RoutedVlan_Ipv6_Address
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address) SetStatus(v E_Address_Status) {
	t.Status = v
}

// SetType sets the value of the leaf Type in the Interface_RoutedVlan_Ipv6_Address
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address) SetType(v E_InetTypes_Ipv6AddressType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address.
func (*Interface_RoutedVlan_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct {
	AcceptMode            *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualLinkLocal      *string                                                        `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-link-local" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// SetAcceptMode sets the value of the leaf AcceptMode in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetAcceptMode(v bool) {
	t.AcceptMode = &v
}

// SetAdvertisementInterval sets the value of the leaf AdvertisementInterval in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetAdvertisementInterval(v uint16) {
	t.AdvertisementInterval = &v
}

// SetCurrentPriority sets the value of the leaf CurrentPriority in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetCurrentPriority(v uint8) {
	t.CurrentPriority = &v
}

// SetPreempt sets the value of the leaf Preempt in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetPreempt(v bool) {
	t.Preempt = &v
}

// SetPreemptDelay sets the value of the leaf PreemptDelay in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetPreemptDelay(v uint16) {
	t.PreemptDelay = &v
}

// SetPriority sets the value of the leaf Priority in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetPriority(v uint8) {
	t.Priority = &v
}

// SetVirtualAddress sets the value of the leaf VirtualAddress in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetVirtualAddress(v []string) {
	t.VirtualAddress = v
}

// SetVirtualLinkLocal sets the value of the leaf VirtualLinkLocal in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetVirtualLinkLocal(v string) {
	t.VirtualLinkLocal = &v
}

// SetVirtualRouterId sets the value of the leaf VirtualRouterId in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) SetVirtualRouterId(v uint8) {
	t.VirtualRouterId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// SetPriorityDecrement sets the value of the leaf PriorityDecrement in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) SetPriorityDecrement(v uint8) {
	t.PriorityDecrement = &v
}

// SetTrackInterface sets the value of the leaf TrackInterface in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) SetTrackInterface(v []string) {
	t.TrackInterface = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InMulticastOctets  *uint64 `path:"in-multicast-octets" module:"openconfig-if-ip"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutMulticastOctets *uint64 `path:"out-multicast-octets" module:"openconfig-if-ip"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// SetInDiscardedPkts sets the value of the leaf InDiscardedPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInDiscardedPkts(v uint64) {
	t.InDiscardedPkts = &v
}

// SetInErrorPkts sets the value of the leaf InErrorPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInErrorPkts(v uint64) {
	t.InErrorPkts = &v
}

// SetInForwardedOctets sets the value of the leaf InForwardedOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInForwardedOctets(v uint64) {
	t.InForwardedOctets = &v
}

// SetInForwardedPkts sets the value of the leaf InForwardedPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInForwardedPkts(v uint64) {
	t.InForwardedPkts = &v
}

// SetInMulticastOctets sets the value of the leaf InMulticastOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInMulticastOctets(v uint64) {
	t.InMulticastOctets = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetOutDiscardedPkts sets the value of the leaf OutDiscardedPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutDiscardedPkts(v uint64) {
	t.OutDiscardedPkts = &v
}

// SetOutErrorPkts sets the value of the leaf OutErrorPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutErrorPkts(v uint64) {
	t.OutErrorPkts = &v
}

// SetOutForwardedOctets sets the value of the leaf OutForwardedOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutForwardedOctets(v uint64) {
	t.OutForwardedOctets = &v
}

// SetOutForwardedPkts sets the value of the leaf OutForwardedPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutForwardedPkts(v uint64) {
	t.OutForwardedPkts = &v
}

// SetOutMulticastOctets sets the value of the leaf OutMulticastOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutMulticastOctets(v uint64) {
	t.OutMulticastOctets = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_RoutedVlan_Ipv6_Counters
// struct.
func (t *Interface_RoutedVlan_Ipv6_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Counters.
func (*Interface_RoutedVlan_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv6_Neighbor struct {
	Ip               *string                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	IsRouter         *bool                    `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	LinkLayerAddress *string                  `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	NeighborState    E_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin    `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetNeighborState() E_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// SetIp sets the value of the leaf Ip in the Interface_RoutedVlan_Ipv6_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) SetIp(v string) {
	t.Ip = &v
}

// SetIsRouter sets the value of the leaf IsRouter in the Interface_RoutedVlan_Ipv6_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) SetIsRouter(v bool) {
	t.IsRouter = &v
}

// SetLinkLayerAddress sets the value of the leaf LinkLayerAddress in the Interface_RoutedVlan_Ipv6_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) SetLinkLayerAddress(v string) {
	t.LinkLayerAddress = &v
}

// SetNeighborState sets the value of the leaf NeighborState in the Interface_RoutedVlan_Ipv6_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) SetNeighborState(v E_Neighbor_NeighborState) {
	t.NeighborState = v
}

// SetOrigin sets the value of the leaf Origin in the Interface_RoutedVlan_Ipv6_Neighbor
// struct.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) SetOrigin(v E_IfIp_NeighborOrigin) {
	t.Origin = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Neighbor.
func (*Interface_RoutedVlan_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/router-advertisement YANG schema element.
type Interface_RoutedVlan_Ipv6_RouterAdvertisement struct {
	Enable      *bool                                                            `path:"config/enable" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enable" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Interval    *uint32                                                          `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Lifetime    *uint32                                                          `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Managed     *bool                                                            `path:"config/managed" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/managed" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mode        E_RouterAdvertisement_Mode                                       `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	OtherConfig *bool                                                            `path:"config/other-config" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/other-config" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Prefix      map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix `path:"prefixes/prefix" module:"openconfig-if-ip/openconfig-if-ip"`
	Suppress    *bool                                                            `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/suppress" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// Interface_RoutedVlan_Ipv6_RouterAdvertisement struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) NewPrefix(Prefix string) (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the Interface_RoutedVlan_Ipv6_RouterAdvertisement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefixMap returns the list (map) from Interface_RoutedVlan_Ipv6_RouterAdvertisement.
//
// It initializes the field if not already initialized.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetOrCreatePrefixMap() map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix {
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix)
	}
	return t.Prefix
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetOrCreatePrefix(Prefix string) *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetPrefix(Prefix string) *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_RouterAdvertisement. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct to the
// list Prefix of Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) AppendPrefix(v *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return true
	}
	return *t.Enable
}

// GetInterval retrieves the value of the leaf Interval from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetManaged retrieves the value of the leaf Managed from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Managed is set, it can
// safely use t.GetManaged() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Managed == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetManaged() bool {
	if t == nil || t.Managed == nil {
		return false
	}
	return *t.Managed
}

// GetMode retrieves the value of the leaf Mode from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetMode() E_RouterAdvertisement_Mode {
	if t == nil || t.Mode == 0 {
		return RouterAdvertisement_Mode_ALL
	}
	return t.Mode
}

// GetOtherConfig retrieves the value of the leaf OtherConfig from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfig is set, it can
// safely use t.GetOtherConfig() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfig == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetOtherConfig() bool {
	if t == nil || t.OtherConfig == nil {
		return false
	}
	return *t.OtherConfig
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// SetEnable sets the value of the leaf Enable in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetEnable(v bool) {
	t.Enable = &v
}

// SetInterval sets the value of the leaf Interval in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetInterval(v uint32) {
	t.Interval = &v
}

// SetLifetime sets the value of the leaf Lifetime in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetLifetime(v uint32) {
	t.Lifetime = &v
}

// SetManaged sets the value of the leaf Managed in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetManaged(v bool) {
	t.Managed = &v
}

// SetMode sets the value of the leaf Mode in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetMode(v E_RouterAdvertisement_Mode) {
	t.Mode = v
}

// SetOtherConfig sets the value of the leaf OtherConfig in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetOtherConfig(v bool) {
	t.OtherConfig = &v
}

// SetSuppress sets the value of the leaf Suppress in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) SetSuppress(v bool) {
	t.Suppress = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = true
		t.Enable = &v
	}
	if t.Managed == nil {
		var v bool = false
		t.Managed = &v
	}
	if t.Mode == 0 {
		t.Mode = RouterAdvertisement_Mode_ALL
	}
	if t.OtherConfig == nil {
		var v bool = false
		t.OtherConfig = &v
	}
	if t.Suppress == nil {
		var v bool = false
		t.Suppress = &v
	}
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_RouterAdvertisement.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes/prefix YANG schema element.
type Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct {
	DisableAdvertisement     *bool   `path:"config/disable-advertisement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/disable-advertisement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DisableAutoconfiguration *bool   `path:"config/disable-autoconfiguration" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/disable-autoconfiguration" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	EnableOnlink             *bool   `path:"config/enable-onlink" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enable-onlink" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreferredLifetime        *uint32 `path:"config/preferred-lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preferred-lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Prefix                   *string `path:"config/prefix|prefix" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/prefix|prefix" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ValidLifetime            *uint32 `path:"config/valid-lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/valid-lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) IsYANGGoStruct() {}

// GetDisableAdvertisement retrieves the value of the leaf DisableAdvertisement from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAdvertisement is set, it can
// safely use t.GetDisableAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAdvertisement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetDisableAdvertisement() bool {
	if t == nil || t.DisableAdvertisement == nil {
		return false
	}
	return *t.DisableAdvertisement
}

// GetDisableAutoconfiguration retrieves the value of the leaf DisableAutoconfiguration from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAutoconfiguration is set, it can
// safely use t.GetDisableAutoconfiguration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAutoconfiguration == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetDisableAutoconfiguration() bool {
	if t == nil || t.DisableAutoconfiguration == nil {
		return false
	}
	return *t.DisableAutoconfiguration
}

// GetEnableOnlink retrieves the value of the leaf EnableOnlink from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableOnlink is set, it can
// safely use t.GetEnableOnlink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableOnlink == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetEnableOnlink() bool {
	if t == nil || t.EnableOnlink == nil {
		return false
	}
	return *t.EnableOnlink
}

// GetPreferredLifetime retrieves the value of the leaf PreferredLifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferredLifetime is set, it can
// safely use t.GetPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetPreferredLifetime() uint32 {
	if t == nil || t.PreferredLifetime == nil {
		return 0
	}
	return *t.PreferredLifetime
}

// GetPrefix retrieves the value of the leaf Prefix from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetValidLifetime retrieves the value of the leaf ValidLifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValidLifetime is set, it can
// safely use t.GetValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetValidLifetime() uint32 {
	if t == nil || t.ValidLifetime == nil {
		return 0
	}
	return *t.ValidLifetime
}

// SetDisableAdvertisement sets the value of the leaf DisableAdvertisement in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetDisableAdvertisement(v bool) {
	t.DisableAdvertisement = &v
}

// SetDisableAutoconfiguration sets the value of the leaf DisableAutoconfiguration in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetDisableAutoconfiguration(v bool) {
	t.DisableAutoconfiguration = &v
}

// SetEnableOnlink sets the value of the leaf EnableOnlink in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetEnableOnlink(v bool) {
	t.EnableOnlink = &v
}

// SetPreferredLifetime sets the value of the leaf PreferredLifetime in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetPreferredLifetime(v uint32) {
	t.PreferredLifetime = &v
}

// SetPrefix sets the value of the leaf Prefix in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetPrefix(v string) {
	t.Prefix = &v
}

// SetValidLifetime sets the value of the leaf ValidLifetime in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) SetValidLifetime(v uint32) {
	t.ValidLifetime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered struct {
	Enabled      *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// SetEnabled sets the value of the leaf Enabled in the Interface_RoutedVlan_Ipv6_Unnumbered
// struct.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) SetEnabled(v bool) {
	t.Enabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface YANG schema element.
type Interface_Subinterface struct {
	AdminStatus E_Interface_AdminStatus          `path:"state/admin-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Counters    *Interface_Subinterface_Counters `path:"state/counters" module:"openconfig-interfaces/openconfig-interfaces"`
	Cpu         *bool                            `path:"state/cpu" module:"openconfig-interfaces/openconfig-interfaces"`
	Description *string                          `path:"config/description" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/description" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Enabled     *bool                            `path:"config/enabled" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/enabled" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Ifindex     *uint32                          `path:"state/ifindex" module:"openconfig-interfaces/openconfig-interfaces"`
	Index       *uint32                          `path:"config/index|index" module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces" shadow-path:"state/index|index" shadow-module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces"`
	Ipv4        *Interface_Subinterface_Ipv4     `path:"ipv4" module:"openconfig-if-ip"`
	Ipv6        *Interface_Subinterface_Ipv6     `path:"ipv6" module:"openconfig-if-ip"`
	LastChange  *uint64                          `path:"state/last-change" module:"openconfig-interfaces/openconfig-interfaces"`
	Logical     *bool                            `path:"state/logical" module:"openconfig-interfaces/openconfig-interfaces"`
	Management  *bool                            `path:"state/management" module:"openconfig-interfaces/openconfig-interfaces"`
	Name        *string                          `path:"state/name" module:"openconfig-interfaces/openconfig-interfaces"`
	OperStatus  E_Interface_OperStatus           `path:"state/oper-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Vlan        *Interface_Subinterface_Vlan     `path:"vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateCounters() *Interface_Subinterface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Counters{}
	return t.Counters
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv4() *Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv6() *Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateVlan() *Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetCounters() *Interface_Subinterface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv4() *Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv6() *Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetVlan() *Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetAdminStatus() E_Interface_AdminStatus {
	if t == nil || t.AdminStatus == 0 {
		return 0
	}
	return t.AdminStatus
}

// GetCpu retrieves the value of the leaf Cpu from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cpu is set, it can
// safely use t.GetCpu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cpu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetCpu() bool {
	if t == nil || t.Cpu == nil {
		return false
	}
	return *t.Cpu
}

// GetDescription retrieves the value of the leaf Description from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetIfindex retrieves the value of the leaf Ifindex from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ifindex is set, it can
// safely use t.GetIfindex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ifindex == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIfindex() uint32 {
	if t == nil || t.Ifindex == nil {
		return 0
	}
	return *t.Ifindex
}

// GetIndex retrieves the value of the leaf Index from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetLastChange retrieves the value of the leaf LastChange from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetLogical retrieves the value of the leaf Logical from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Logical is set, it can
// safely use t.GetLogical() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Logical == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLogical() bool {
	if t == nil || t.Logical == nil {
		return false
	}
	return *t.Logical
}

// GetManagement retrieves the value of the leaf Management from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Management is set, it can
// safely use t.GetManagement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Management == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetManagement() bool {
	if t == nil || t.Management == nil {
		return false
	}
	return *t.Management
}

// GetName retrieves the value of the leaf Name from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetOperStatus() E_Interface_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// SetAdminStatus sets the value of the leaf AdminStatus in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetAdminStatus(v E_Interface_AdminStatus) {
	t.AdminStatus = v
}

// SetCpu sets the value of the leaf Cpu in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetCpu(v bool) {
	t.Cpu = &v
}

// SetDescription sets the value of the leaf Description in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetDescription(v string) {
	t.Description = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetIfindex sets the value of the leaf Ifindex in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetIfindex(v uint32) {
	t.Ifindex = &v
}

// SetIndex sets the value of the leaf Index in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetIndex(v uint32) {
	t.Index = &v
}

// SetLastChange sets the value of the leaf LastChange in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetLastChange(v uint64) {
	t.LastChange = &v
}

// SetLogical sets the value of the leaf Logical in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetLogical(v bool) {
	t.Logical = &v
}

// SetManagement sets the value of the leaf Management in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetManagement(v bool) {
	t.Management = &v
}

// SetName sets the value of the leaf Name in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetName(v string) {
	t.Name = &v
}

// SetOperStatus sets the value of the leaf OperStatus in the Interface_Subinterface
// struct.
func (t *Interface_Subinterface) SetOperStatus(v E_Interface_OperStatus) {
	t.OperStatus = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	if t.Index == nil {
		var v uint32 = 0
		t.Index = &v
	}
	t.Counters.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface struct, which is a YANG list entry.
func (t *Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface.
func (*Interface_Subinterface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/state/counters YANG schema element.
type Interface_Subinterface_Counters struct {
	CarrierTransitions *uint64 `path:"carrier-transitions" module:"openconfig-interfaces"`
	InBroadcastPkts    *uint64 `path:"in-broadcast-pkts" module:"openconfig-interfaces"`
	InDiscards         *uint64 `path:"in-discards" module:"openconfig-interfaces"`
	InErrors           *uint64 `path:"in-errors" module:"openconfig-interfaces"`
	InFcsErrors        *uint64 `path:"in-fcs-errors" module:"openconfig-interfaces"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-interfaces"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-interfaces"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-interfaces"`
	InUnicastPkts      *uint64 `path:"in-unicast-pkts" module:"openconfig-interfaces"`
	InUnknownProtos    *uint64 `path:"in-unknown-protos" module:"openconfig-interfaces"`
	LastClear          *uint64 `path:"last-clear" module:"openconfig-interfaces"`
	OutBroadcastPkts   *uint64 `path:"out-broadcast-pkts" module:"openconfig-interfaces"`
	OutDiscards        *uint64 `path:"out-discards" module:"openconfig-interfaces"`
	OutErrors          *uint64 `path:"out-errors" module:"openconfig-interfaces"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-interfaces"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-interfaces"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-interfaces"`
	OutUnicastPkts     *uint64 `path:"out-unicast-pkts" module:"openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Counters) IsYANGGoStruct() {}

// GetCarrierTransitions retrieves the value of the leaf CarrierTransitions from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CarrierTransitions is set, it can
// safely use t.GetCarrierTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CarrierTransitions == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetCarrierTransitions() uint64 {
	if t == nil || t.CarrierTransitions == nil {
		return 0
	}
	return *t.CarrierTransitions
}

// GetInBroadcastPkts retrieves the value of the leaf InBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBroadcastPkts is set, it can
// safely use t.GetInBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInBroadcastPkts() uint64 {
	if t == nil || t.InBroadcastPkts == nil {
		return 0
	}
	return *t.InBroadcastPkts
}

// GetInDiscards retrieves the value of the leaf InDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscards is set, it can
// safely use t.GetInDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInDiscards() uint64 {
	if t == nil || t.InDiscards == nil {
		return 0
	}
	return *t.InDiscards
}

// GetInErrors retrieves the value of the leaf InErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrors is set, it can
// safely use t.GetInErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInErrors() uint64 {
	if t == nil || t.InErrors == nil {
		return 0
	}
	return *t.InErrors
}

// GetInFcsErrors retrieves the value of the leaf InFcsErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFcsErrors is set, it can
// safely use t.GetInFcsErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFcsErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInFcsErrors() uint64 {
	if t == nil || t.InFcsErrors == nil {
		return 0
	}
	return *t.InFcsErrors
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInUnicastPkts retrieves the value of the leaf InUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnicastPkts is set, it can
// safely use t.GetInUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnicastPkts() uint64 {
	if t == nil || t.InUnicastPkts == nil {
		return 0
	}
	return *t.InUnicastPkts
}

// GetInUnknownProtos retrieves the value of the leaf InUnknownProtos from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnknownProtos is set, it can
// safely use t.GetInUnknownProtos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnknownProtos == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnknownProtos() uint64 {
	if t == nil || t.InUnknownProtos == nil {
		return 0
	}
	return *t.InUnknownProtos
}

// GetLastClear retrieves the value of the leaf LastClear from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetOutBroadcastPkts retrieves the value of the leaf OutBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBroadcastPkts is set, it can
// safely use t.GetOutBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutBroadcastPkts() uint64 {
	if t == nil || t.OutBroadcastPkts == nil {
		return 0
	}
	return *t.OutBroadcastPkts
}

// GetOutDiscards retrieves the value of the leaf OutDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscards is set, it can
// safely use t.GetOutDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutDiscards() uint64 {
	if t == nil || t.OutDiscards == nil {
		return 0
	}
	return *t.OutDiscards
}

// GetOutErrors retrieves the value of the leaf OutErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrors is set, it can
// safely use t.GetOutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutErrors() uint64 {
	if t == nil || t.OutErrors == nil {
		return 0
	}
	return *t.OutErrors
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// GetOutUnicastPkts retrieves the value of the leaf OutUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUnicastPkts is set, it can
// safely use t.GetOutUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutUnicastPkts() uint64 {
	if t == nil || t.OutUnicastPkts == nil {
		return 0
	}
	return *t.OutUnicastPkts
}

// SetCarrierTransitions sets the value of the leaf CarrierTransitions in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetCarrierTransitions(v uint64) {
	t.CarrierTransitions = &v
}

// SetInBroadcastPkts sets the value of the leaf InBroadcastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInBroadcastPkts(v uint64) {
	t.InBroadcastPkts = &v
}

// SetInDiscards sets the value of the leaf InDiscards in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInDiscards(v uint64) {
	t.InDiscards = &v
}

// SetInErrors sets the value of the leaf InErrors in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInErrors(v uint64) {
	t.InErrors = &v
}

// SetInFcsErrors sets the value of the leaf InFcsErrors in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInFcsErrors(v uint64) {
	t.InFcsErrors = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetInUnicastPkts sets the value of the leaf InUnicastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInUnicastPkts(v uint64) {
	t.InUnicastPkts = &v
}

// SetInUnknownProtos sets the value of the leaf InUnknownProtos in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetInUnknownProtos(v uint64) {
	t.InUnknownProtos = &v
}

// SetLastClear sets the value of the leaf LastClear in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetLastClear(v uint64) {
	t.LastClear = &v
}

// SetOutBroadcastPkts sets the value of the leaf OutBroadcastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutBroadcastPkts(v uint64) {
	t.OutBroadcastPkts = &v
}

// SetOutDiscards sets the value of the leaf OutDiscards in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutDiscards(v uint64) {
	t.OutDiscards = &v
}

// SetOutErrors sets the value of the leaf OutErrors in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutErrors(v uint64) {
	t.OutErrors = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// SetOutUnicastPkts sets the value of the leaf OutUnicastPkts in the Interface_Subinterface_Counters
// struct.
func (t *Interface_Subinterface_Counters) SetOutUnicastPkts(v uint64) {
	t.OutUnicastPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Counters.
func (*Interface_Subinterface_Counters) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Ipv4 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4 YANG schema element.
type Interface_Subinterface_Ipv4 struct {
	Address               map[string]*Interface_Subinterface_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters              *Interface_Subinterface_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient            *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled               *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	GratuitousArpAccepted *bool                                            `path:"config/gratuitous-arp-accepted" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/gratuitous-arp-accepted" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                   *uint16                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor              map[string]*Interface_Subinterface_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ProxyArp              *Interface_Subinterface_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	Unnumbered            *Interface_Subinterface_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewAddress(Ip string) (*Interface_Subinterface_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddressMap returns the list (map) from Interface_Subinterface_Ipv4.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddressMap() map[string]*Interface_Subinterface_Ipv4_Address {
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}
	return t.Address
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv4_Address struct to the
// list Address of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendAddress(v *Interface_Subinterface_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from Interface_Subinterface_Ipv4.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighborMap() map[string]*Interface_Subinterface_Ipv4_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendNeighbor(v *Interface_Subinterface_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateCounters() *Interface_Subinterface_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_Subinterface_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetCounters() *Interface_Subinterface_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetGratuitousArpAccepted retrieves the value of the leaf GratuitousArpAccepted from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GratuitousArpAccepted is set, it can
// safely use t.GetGratuitousArpAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GratuitousArpAccepted == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetGratuitousArpAccepted() bool {
	if t == nil || t.GratuitousArpAccepted == nil {
		return false
	}
	return *t.GratuitousArpAccepted
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// SetDhcpClient sets the value of the leaf DhcpClient in the Interface_Subinterface_Ipv4
// struct.
func (t *Interface_Subinterface_Ipv4) SetDhcpClient(v bool) {
	t.DhcpClient = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface_Subinterface_Ipv4
// struct.
func (t *Interface_Subinterface_Ipv4) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetGratuitousArpAccepted sets the value of the leaf GratuitousArpAccepted in the Interface_Subinterface_Ipv4
// struct.
func (t *Interface_Subinterface_Ipv4) SetGratuitousArpAccepted(v bool) {
	t.GratuitousArpAccepted = &v
}

// SetMtu sets the value of the leaf Mtu in the Interface_Subinterface_Ipv4
// struct.
func (t *Interface_Subinterface_Ipv4) SetMtu(v uint16) {
	t.Mtu = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	t.ProxyArp.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4.
func (*Interface_Subinterface_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address YANG schema element.
type Interface_Subinterface_Ipv4_Address struct {
	Ip           *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Type         E_IfIp_Ipv4AddressType                                   `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/type" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroupMap returns the list (map) from Interface_Subinterface_Ipv4_Address.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroupMap() map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup {
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}
	return t.VrrpGroup
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetType retrieves the value of the leaf Type from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetType() E_IfIp_Ipv4AddressType {
	if t == nil || t.Type == 0 {
		return IfIp_Ipv4AddressType_PRIMARY
	}
	return t.Type
}

// SetIp sets the value of the leaf Ip in the Interface_Subinterface_Ipv4_Address
// struct.
func (t *Interface_Subinterface_Ipv4_Address) SetIp(v string) {
	t.Ip = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_Subinterface_Ipv4_Address
// struct.
func (t *Interface_Subinterface_Ipv4_Address) SetOrigin(v E_IfIp_IpAddressOrigin) {
	t.Origin = v
}

// SetPrefixLength sets the value of the leaf PrefixLength in the Interface_Subinterface_Ipv4_Address
// struct.
func (t *Interface_Subinterface_Ipv4_Address) SetPrefixLength(v uint8) {
	t.PrefixLength = &v
}

// SetType sets the value of the leaf Type in the Interface_Subinterface_Ipv4_Address
// struct.
func (t *Interface_Subinterface_Ipv4_Address) SetType(v E_IfIp_Ipv4AddressType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = IfIp_Ipv4AddressType_PRIMARY
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address.
func (*Interface_Subinterface_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup struct {
	AcceptMode            *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// SetAcceptMode sets the value of the leaf AcceptMode in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetAcceptMode(v bool) {
	t.AcceptMode = &v
}

// SetAdvertisementInterval sets the value of the leaf AdvertisementInterval in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetAdvertisementInterval(v uint16) {
	t.AdvertisementInterval = &v
}

// SetCurrentPriority sets the value of the leaf CurrentPriority in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetCurrentPriority(v uint8) {
	t.CurrentPriority = &v
}

// SetPreempt sets the value of the leaf Preempt in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetPreempt(v bool) {
	t.Preempt = &v
}

// SetPreemptDelay sets the value of the leaf PreemptDelay in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetPreemptDelay(v uint16) {
	t.PreemptDelay = &v
}

// SetPriority sets the value of the leaf Priority in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetPriority(v uint8) {
	t.Priority = &v
}

// SetVirtualAddress sets the value of the leaf VirtualAddress in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetVirtualAddress(v []string) {
	t.VirtualAddress = v
}

// SetVirtualRouterId sets the value of the leaf VirtualRouterId in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) SetVirtualRouterId(v uint8) {
	t.VirtualRouterId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// SetPriorityDecrement sets the value of the leaf PriorityDecrement in the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) SetPriorityDecrement(v uint8) {
	t.PriorityDecrement = &v
}

// SetTrackInterface sets the value of the leaf TrackInterface in the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) SetTrackInterface(v []string) {
	t.TrackInterface = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/state/counters YANG schema element.
type Interface_Subinterface_Ipv4_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InMulticastOctets  *uint64 `path:"in-multicast-octets" module:"openconfig-if-ip"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutMulticastOctets *uint64 `path:"out-multicast-octets" module:"openconfig-if-ip"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// SetInDiscardedPkts sets the value of the leaf InDiscardedPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInDiscardedPkts(v uint64) {
	t.InDiscardedPkts = &v
}

// SetInErrorPkts sets the value of the leaf InErrorPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInErrorPkts(v uint64) {
	t.InErrorPkts = &v
}

// SetInForwardedOctets sets the value of the leaf InForwardedOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInForwardedOctets(v uint64) {
	t.InForwardedOctets = &v
}

// SetInForwardedPkts sets the value of the leaf InForwardedPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInForwardedPkts(v uint64) {
	t.InForwardedPkts = &v
}

// SetInMulticastOctets sets the value of the leaf InMulticastOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInMulticastOctets(v uint64) {
	t.InMulticastOctets = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetOutDiscardedPkts sets the value of the leaf OutDiscardedPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutDiscardedPkts(v uint64) {
	t.OutDiscardedPkts = &v
}

// SetOutErrorPkts sets the value of the leaf OutErrorPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutErrorPkts(v uint64) {
	t.OutErrorPkts = &v
}

// SetOutForwardedOctets sets the value of the leaf OutForwardedOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutForwardedOctets(v uint64) {
	t.OutForwardedOctets = &v
}

// SetOutForwardedPkts sets the value of the leaf OutForwardedPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutForwardedPkts(v uint64) {
	t.OutForwardedPkts = &v
}

// SetOutMulticastOctets sets the value of the leaf OutMulticastOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutMulticastOctets(v uint64) {
	t.OutMulticastOctets = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_Subinterface_Ipv4_Counters
// struct.
func (t *Interface_Subinterface_Ipv4_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Counters.
func (*Interface_Subinterface_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv4_Neighbor struct {
	Ip               *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	LinkLayerAddress *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// SetIp sets the value of the leaf Ip in the Interface_Subinterface_Ipv4_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv4_Neighbor) SetIp(v string) {
	t.Ip = &v
}

// SetLinkLayerAddress sets the value of the leaf LinkLayerAddress in the Interface_Subinterface_Ipv4_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv4_Neighbor) SetLinkLayerAddress(v string) {
	t.LinkLayerAddress = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_Subinterface_Ipv4_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv4_Neighbor) SetOrigin(v E_IfIp_NeighborOrigin) {
	t.Origin = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Neighbor.
func (*Interface_Subinterface_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp YANG schema element.
type Interface_Subinterface_Ipv4_ProxyArp struct {
	Mode E_ProxyArp_Mode `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_Subinterface_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_ProxyArp) GetMode() E_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// SetMode sets the value of the leaf Mode in the Interface_Subinterface_Ipv4_ProxyArp
// struct.
func (t *Interface_Subinterface_Ipv4_ProxyArp) SetMode(v E_ProxyArp_Mode) {
	t.Mode = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_ProxyArp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_ProxyArp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = ProxyArp_Mode_DISABLE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_ProxyArp.
func (*Interface_Subinterface_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered struct {
	Enabled      *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// SetEnabled sets the value of the leaf Enabled in the Interface_Subinterface_Ipv4_Unnumbered
// struct.
func (t *Interface_Subinterface_Ipv4_Unnumbered) SetEnabled(v bool) {
	t.Enabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered.
func (*Interface_Subinterface_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6 YANG schema element.
type Interface_Subinterface_Ipv6 struct {
	Address                map[string]*Interface_Subinterface_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters               *Interface_Subinterface_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient             *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DupAddrDetectTransmits *uint32                                          `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dup-addr-detect-transmits" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled                *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	LearnUnsolicited       E_Ipv6_LearnUnsolicited                          `path:"config/learn-unsolicited" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/learn-unsolicited" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                    *uint32                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor               map[string]*Interface_Subinterface_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	RouterAdvertisement    *Interface_Subinterface_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	Unnumbered             *Interface_Subinterface_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewAddress(Ip string) (*Interface_Subinterface_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddressMap returns the list (map) from Interface_Subinterface_Ipv6.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddressMap() map[string]*Interface_Subinterface_Ipv6_Address {
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}
	return t.Address
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv6_Address struct to the
// list Address of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendAddress(v *Interface_Subinterface_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from Interface_Subinterface_Ipv6.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighborMap() map[string]*Interface_Subinterface_Ipv6_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendNeighbor(v *Interface_Subinterface_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateCounters() *Interface_Subinterface_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetCounters() *Interface_Subinterface_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetLearnUnsolicited retrieves the value of the leaf LearnUnsolicited from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearnUnsolicited is set, it can
// safely use t.GetLearnUnsolicited() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearnUnsolicited == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetLearnUnsolicited() E_Ipv6_LearnUnsolicited {
	if t == nil || t.LearnUnsolicited == 0 {
		return Ipv6_LearnUnsolicited_NONE
	}
	return t.LearnUnsolicited
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// SetDhcpClient sets the value of the leaf DhcpClient in the Interface_Subinterface_Ipv6
// struct.
func (t *Interface_Subinterface_Ipv6) SetDhcpClient(v bool) {
	t.DhcpClient = &v
}

// SetDupAddrDetectTransmits sets the value of the leaf DupAddrDetectTransmits in the Interface_Subinterface_Ipv6
// struct.
func (t *Interface_Subinterface_Ipv6) SetDupAddrDetectTransmits(v uint32) {
	t.DupAddrDetectTransmits = &v
}

// SetEnabled sets the value of the leaf Enabled in the Interface_Subinterface_Ipv6
// struct.
func (t *Interface_Subinterface_Ipv6) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetLearnUnsolicited sets the value of the leaf LearnUnsolicited in the Interface_Subinterface_Ipv6
// struct.
func (t *Interface_Subinterface_Ipv6) SetLearnUnsolicited(v E_Ipv6_LearnUnsolicited) {
	t.LearnUnsolicited = v
}

// SetMtu sets the value of the leaf Mtu in the Interface_Subinterface_Ipv6
// struct.
func (t *Interface_Subinterface_Ipv6) SetMtu(v uint32) {
	t.Mtu = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.DupAddrDetectTransmits == nil {
		var v uint32 = 1
		t.DupAddrDetectTransmits = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	if t.LearnUnsolicited == 0 {
		t.LearnUnsolicited = Ipv6_LearnUnsolicited_NONE
	}
	t.Counters.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6.
func (*Interface_Subinterface_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address YANG schema element.
type Interface_Subinterface_Ipv6_Address struct {
	Ip           *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Status       E_Address_Status                                         `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	Type         E_InetTypes_Ipv6AddressType                              `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/type" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroupMap returns the list (map) from Interface_Subinterface_Ipv6_Address.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroupMap() map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup {
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}
	return t.VrrpGroup
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetStatus() E_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// GetType retrieves the value of the leaf Type from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetType() E_InetTypes_Ipv6AddressType {
	if t == nil || t.Type == 0 {
		return InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	return t.Type
}

// SetIp sets the value of the leaf Ip in the Interface_Subinterface_Ipv6_Address
// struct.
func (t *Interface_Subinterface_Ipv6_Address) SetIp(v string) {
	t.Ip = &v
}

// SetOrigin sets the value of the leaf Origin in the Interface_Subinterface_Ipv6_Address
// struct.
func (t *Interface_Subinterface_Ipv6_Address) SetOrigin(v E_IfIp_IpAddressOrigin) {
	t.Origin = v
}

// SetPrefixLength sets the value of the leaf PrefixLength in the Interface_Subinterface_Ipv6_Address
// struct.
func (t *Interface_Subinterface_Ipv6_Address) SetPrefixLength(v uint8) {
	t.PrefixLength = &v
}

// SetStatus sets the value of the leaf Status in the Interface_Subinterface_Ipv6_Address
// struct.
func (t *Interface_Subinterface_Ipv6_Address) SetStatus(v E_Address_Status) {
	t.Status = v
}

// SetType sets the value of the leaf Type in the Interface_Subinterface_Ipv6_Address
// struct.
func (t *Interface_Subinterface_Ipv6_Address) SetType(v E_InetTypes_Ipv6AddressType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address.
func (*Interface_Subinterface_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup struct {
	AcceptMode            *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualLinkLocal      *string                                                          `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-link-local" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// SetAcceptMode sets the value of the leaf AcceptMode in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetAcceptMode(v bool) {
	t.AcceptMode = &v
}

// SetAdvertisementInterval sets the value of the leaf AdvertisementInterval in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetAdvertisementInterval(v uint16) {
	t.AdvertisementInterval = &v
}

// SetCurrentPriority sets the value of the leaf CurrentPriority in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetCurrentPriority(v uint8) {
	t.CurrentPriority = &v
}

// SetPreempt sets the value of the leaf Preempt in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetPreempt(v bool) {
	t.Preempt = &v
}

// SetPreemptDelay sets the value of the leaf PreemptDelay in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetPreemptDelay(v uint16) {
	t.PreemptDelay = &v
}

// SetPriority sets the value of the leaf Priority in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetPriority(v uint8) {
	t.Priority = &v
}

// SetVirtualAddress sets the value of the leaf VirtualAddress in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetVirtualAddress(v []string) {
	t.VirtualAddress = v
}

// SetVirtualLinkLocal sets the value of the leaf VirtualLinkLocal in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetVirtualLinkLocal(v string) {
	t.VirtualLinkLocal = &v
}

// SetVirtualRouterId sets the value of the leaf VirtualRouterId in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) SetVirtualRouterId(v uint8) {
	t.VirtualRouterId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// SetPriorityDecrement sets the value of the leaf PriorityDecrement in the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) SetPriorityDecrement(v uint8) {
	t.PriorityDecrement = &v
}

// SetTrackInterface sets the value of the leaf TrackInterface in the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) SetTrackInterface(v []string) {
	t.TrackInterface = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/state/counters YANG schema element.
type Interface_Subinterface_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InMulticastOctets  *uint64 `path:"in-multicast-octets" module:"openconfig-if-ip"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutMulticastOctets *uint64 `path:"out-multicast-octets" module:"openconfig-if-ip"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// SetInDiscardedPkts sets the value of the leaf InDiscardedPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInDiscardedPkts(v uint64) {
	t.InDiscardedPkts = &v
}

// SetInErrorPkts sets the value of the leaf InErrorPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInErrorPkts(v uint64) {
	t.InErrorPkts = &v
}

// SetInForwardedOctets sets the value of the leaf InForwardedOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInForwardedOctets(v uint64) {
	t.InForwardedOctets = &v
}

// SetInForwardedPkts sets the value of the leaf InForwardedPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInForwardedPkts(v uint64) {
	t.InForwardedPkts = &v
}

// SetInMulticastOctets sets the value of the leaf InMulticastOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInMulticastOctets(v uint64) {
	t.InMulticastOctets = &v
}

// SetInMulticastPkts sets the value of the leaf InMulticastPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInMulticastPkts(v uint64) {
	t.InMulticastPkts = &v
}

// SetInOctets sets the value of the leaf InOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInOctets(v uint64) {
	t.InOctets = &v
}

// SetInPkts sets the value of the leaf InPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetInPkts(v uint64) {
	t.InPkts = &v
}

// SetOutDiscardedPkts sets the value of the leaf OutDiscardedPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutDiscardedPkts(v uint64) {
	t.OutDiscardedPkts = &v
}

// SetOutErrorPkts sets the value of the leaf OutErrorPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutErrorPkts(v uint64) {
	t.OutErrorPkts = &v
}

// SetOutForwardedOctets sets the value of the leaf OutForwardedOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutForwardedOctets(v uint64) {
	t.OutForwardedOctets = &v
}

// SetOutForwardedPkts sets the value of the leaf OutForwardedPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutForwardedPkts(v uint64) {
	t.OutForwardedPkts = &v
}

// SetOutMulticastOctets sets the value of the leaf OutMulticastOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutMulticastOctets(v uint64) {
	t.OutMulticastOctets = &v
}

// SetOutMulticastPkts sets the value of the leaf OutMulticastPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutMulticastPkts(v uint64) {
	t.OutMulticastPkts = &v
}

// SetOutOctets sets the value of the leaf OutOctets in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutOctets(v uint64) {
	t.OutOctets = &v
}

// SetOutPkts sets the value of the leaf OutPkts in the Interface_Subinterface_Ipv6_Counters
// struct.
func (t *Interface_Subinterface_Ipv6_Counters) SetOutPkts(v uint64) {
	t.OutPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Counters.
func (*Interface_Subinterface_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv6_Neighbor struct {
	Ip               *string                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	IsRouter         *bool                    `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	LinkLayerAddress *string                  `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	NeighborState    E_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin    `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetNeighborState() E_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// SetIp sets the value of the leaf Ip in the Interface_Subinterface_Ipv6_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv6_Neighbor) SetIp(v string) {
	t.Ip = &v
}

// SetIsRouter sets the value of the leaf IsRouter in the Interface_Subinterface_Ipv6_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv6_Neighbor) SetIsRouter(v bool) {
	t.IsRouter = &v
}

// SetLinkLayerAddress sets the value of the leaf LinkLayerAddress in the Interface_Subinterface_Ipv6_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv6_Neighbor) SetLinkLayerAddress(v string) {
	t.LinkLayerAddress = &v
}

// SetNeighborState sets the value of the leaf NeighborState in the Interface_Subinterface_Ipv6_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv6_Neighbor) SetNeighborState(v E_Neighbor_NeighborState) {
	t.NeighborState = v
}

// SetOrigin sets the value of the leaf Origin in the Interface_Subinterface_Ipv6_Neighbor
// struct.
func (t *Interface_Subinterface_Ipv6_Neighbor) SetOrigin(v E_IfIp_NeighborOrigin) {
	t.Origin = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Neighbor.
func (*Interface_Subinterface_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement struct {
	Enable      *bool                                                              `path:"config/enable" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enable" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Interval    *uint32                                                            `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Lifetime    *uint32                                                            `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Managed     *bool                                                              `path:"config/managed" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/managed" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mode        E_RouterAdvertisement_Mode                                         `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	OtherConfig *bool                                                              `path:"config/other-config" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/other-config" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Prefix      map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix `path:"prefixes/prefix" module:"openconfig-if-ip/openconfig-if-ip"`
	Suppress    *bool                                                              `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/suppress" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// Interface_Subinterface_Ipv6_RouterAdvertisement struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) NewPrefix(Prefix string) (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the Interface_Subinterface_Ipv6_RouterAdvertisement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefixMap returns the list (map) from Interface_Subinterface_Ipv6_RouterAdvertisement.
//
// It initializes the field if not already initialized.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetOrCreatePrefixMap() map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix {
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix)
	}
	return t.Prefix
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_RouterAdvertisement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetOrCreatePrefix(Prefix string) *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of Interface_Subinterface_Ipv6_RouterAdvertisement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetPrefix(Prefix string) *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_RouterAdvertisement. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct to the
// list Prefix of Interface_Subinterface_Ipv6_RouterAdvertisement. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) AppendPrefix(v *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return true
	}
	return *t.Enable
}

// GetInterval retrieves the value of the leaf Interval from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetManaged retrieves the value of the leaf Managed from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Managed is set, it can
// safely use t.GetManaged() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Managed == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetManaged() bool {
	if t == nil || t.Managed == nil {
		return false
	}
	return *t.Managed
}

// GetMode retrieves the value of the leaf Mode from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetMode() E_RouterAdvertisement_Mode {
	if t == nil || t.Mode == 0 {
		return RouterAdvertisement_Mode_ALL
	}
	return t.Mode
}

// GetOtherConfig retrieves the value of the leaf OtherConfig from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfig is set, it can
// safely use t.GetOtherConfig() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfig == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetOtherConfig() bool {
	if t == nil || t.OtherConfig == nil {
		return false
	}
	return *t.OtherConfig
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// SetEnable sets the value of the leaf Enable in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetEnable(v bool) {
	t.Enable = &v
}

// SetInterval sets the value of the leaf Interval in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetInterval(v uint32) {
	t.Interval = &v
}

// SetLifetime sets the value of the leaf Lifetime in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetLifetime(v uint32) {
	t.Lifetime = &v
}

// SetManaged sets the value of the leaf Managed in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetManaged(v bool) {
	t.Managed = &v
}

// SetMode sets the value of the leaf Mode in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetMode(v E_RouterAdvertisement_Mode) {
	t.Mode = v
}

// SetOtherConfig sets the value of the leaf OtherConfig in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetOtherConfig(v bool) {
	t.OtherConfig = &v
}

// SetSuppress sets the value of the leaf Suppress in the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) SetSuppress(v bool) {
	t.Suppress = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = true
		t.Enable = &v
	}
	if t.Managed == nil {
		var v bool = false
		t.Managed = &v
	}
	if t.Mode == 0 {
		t.Mode = RouterAdvertisement_Mode_ALL
	}
	if t.OtherConfig == nil {
		var v bool = false
		t.OtherConfig = &v
	}
	if t.Suppress == nil {
		var v bool = false
		t.Suppress = &v
	}
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes/prefix YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct {
	DisableAdvertisement     *bool   `path:"config/disable-advertisement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/disable-advertisement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DisableAutoconfiguration *bool   `path:"config/disable-autoconfiguration" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/disable-autoconfiguration" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	EnableOnlink             *bool   `path:"config/enable-onlink" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enable-onlink" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreferredLifetime        *uint32 `path:"config/preferred-lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preferred-lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Prefix                   *string `path:"config/prefix|prefix" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/prefix|prefix" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ValidLifetime            *uint32 `path:"config/valid-lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/valid-lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) IsYANGGoStruct() {}

// GetDisableAdvertisement retrieves the value of the leaf DisableAdvertisement from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAdvertisement is set, it can
// safely use t.GetDisableAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAdvertisement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetDisableAdvertisement() bool {
	if t == nil || t.DisableAdvertisement == nil {
		return false
	}
	return *t.DisableAdvertisement
}

// GetDisableAutoconfiguration retrieves the value of the leaf DisableAutoconfiguration from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAutoconfiguration is set, it can
// safely use t.GetDisableAutoconfiguration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAutoconfiguration == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetDisableAutoconfiguration() bool {
	if t == nil || t.DisableAutoconfiguration == nil {
		return false
	}
	return *t.DisableAutoconfiguration
}

// GetEnableOnlink retrieves the value of the leaf EnableOnlink from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableOnlink is set, it can
// safely use t.GetEnableOnlink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableOnlink == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetEnableOnlink() bool {
	if t == nil || t.EnableOnlink == nil {
		return false
	}
	return *t.EnableOnlink
}

// GetPreferredLifetime retrieves the value of the leaf PreferredLifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferredLifetime is set, it can
// safely use t.GetPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetPreferredLifetime() uint32 {
	if t == nil || t.PreferredLifetime == nil {
		return 0
	}
	return *t.PreferredLifetime
}

// GetPrefix retrieves the value of the leaf Prefix from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetValidLifetime retrieves the value of the leaf ValidLifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValidLifetime is set, it can
// safely use t.GetValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetValidLifetime() uint32 {
	if t == nil || t.ValidLifetime == nil {
		return 0
	}
	return *t.ValidLifetime
}

// SetDisableAdvertisement sets the value of the leaf DisableAdvertisement in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetDisableAdvertisement(v bool) {
	t.DisableAdvertisement = &v
}

// SetDisableAutoconfiguration sets the value of the leaf DisableAutoconfiguration in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetDisableAutoconfiguration(v bool) {
	t.DisableAutoconfiguration = &v
}

// SetEnableOnlink sets the value of the leaf EnableOnlink in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetEnableOnlink(v bool) {
	t.EnableOnlink = &v
}

// SetPreferredLifetime sets the value of the leaf PreferredLifetime in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetPreferredLifetime(v uint32) {
	t.PreferredLifetime = &v
}

// SetPrefix sets the value of the leaf Prefix in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetPrefix(v string) {
	t.Prefix = &v
}

// SetValidLifetime sets the value of the leaf ValidLifetime in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) SetValidLifetime(v uint32) {
	t.ValidLifetime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered struct {
	Enabled      *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// SetEnabled sets the value of the leaf Enabled in the Interface_Subinterface_Ipv6_Unnumbered
// struct.
func (t *Interface_Subinterface_Ipv6_Unnumbered) SetEnabled(v bool) {
	t.Enabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered.
func (*Interface_Subinterface_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Vlan represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan YANG schema element.
type Interface_Subinterface_Vlan struct {
	EgressMapping  *Interface_Subinterface_Vlan_EgressMapping  `path:"egress-mapping" module:"openconfig-vlan"`
	IngressMapping *Interface_Subinterface_Vlan_IngressMapping `path:"ingress-mapping" module:"openconfig-vlan"`
	Match          *Interface_Subinterface_Vlan_Match          `path:"match" module:"openconfig-vlan"`
	VlanId         Interface_Subinterface_Vlan_VlanId_Union    `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan) IsYANGGoStruct() {}

// GetOrCreateEgressMapping retrieves the value of the EgressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t.EgressMapping != nil {
		return t.EgressMapping
	}
	t.EgressMapping = &Interface_Subinterface_Vlan_EgressMapping{}
	return t.EgressMapping
}

// GetOrCreateIngressMapping retrieves the value of the IngressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t.IngressMapping != nil {
		return t.IngressMapping
	}
	t.IngressMapping = &Interface_Subinterface_Vlan_IngressMapping{}
	return t.IngressMapping
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateMatch() *Interface_Subinterface_Vlan_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &Interface_Subinterface_Vlan_Match{}
	return t.Match
}

// GetEgressMapping returns the value of the EgressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field EgressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t != nil && t.EgressMapping != nil {
		return t.EgressMapping
	}
	return nil
}

// GetIngressMapping returns the value of the IngressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field IngressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t != nil && t.IngressMapping != nil {
		return t.IngressMapping
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetMatch() *Interface_Subinterface_Vlan_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan) GetVlanId() Interface_Subinterface_Vlan_VlanId_Union {
	if t == nil || t.VlanId == nil {
		return nil
	}
	return t.VlanId
}

// SetVlanId sets the value of the leaf VlanId in the Interface_Subinterface_Vlan
// struct.
func (t *Interface_Subinterface_Vlan) SetVlanId(v Interface_Subinterface_Vlan_VlanId_Union) {
	t.VlanId = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EgressMapping.PopulateDefaults()
	t.IngressMapping.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan.
func (*Interface_Subinterface_Vlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_EgressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping YANG schema element.
type Interface_Subinterface_Vlan_EgressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_EgressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_EgressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// SetTpid sets the value of the leaf Tpid in the Interface_Subinterface_Vlan_EgressMapping
// struct.
func (t *Interface_Subinterface_Vlan_EgressMapping) SetTpid(v E_VlanTypes_TPID_TYPES) {
	t.Tpid = v
}

// SetVlanId sets the value of the leaf VlanId in the Interface_Subinterface_Vlan_EgressMapping
// struct.
func (t *Interface_Subinterface_Vlan_EgressMapping) SetVlanId(v uint16) {
	t.VlanId = &v
}

// SetVlanStackAction sets the value of the leaf VlanStackAction in the Interface_Subinterface_Vlan_EgressMapping
// struct.
func (t *Interface_Subinterface_Vlan_EgressMapping) SetVlanStackAction(v E_VlanTypes_VlanStackAction) {
	t.VlanStackAction = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_EgressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_EgressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_EgressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_EgressMapping.
func (*Interface_Subinterface_Vlan_EgressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_IngressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping YANG schema element.
type Interface_Subinterface_Vlan_IngressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_IngressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_IngressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// SetTpid sets the value of the leaf Tpid in the Interface_Subinterface_Vlan_IngressMapping
// struct.
func (t *Interface_Subinterface_Vlan_IngressMapping) SetTpid(v E_VlanTypes_TPID_TYPES) {
	t.Tpid = v
}

// SetVlanId sets the value of the leaf VlanId in the Interface_Subinterface_Vlan_IngressMapping
// struct.
func (t *Interface_Subinterface_Vlan_IngressMapping) SetVlanId(v uint16) {
	t.VlanId = &v
}

// SetVlanStackAction sets the value of the leaf VlanStackAction in the Interface_Subinterface_Vlan_IngressMapping
// struct.
func (t *Interface_Subinterface_Vlan_IngressMapping) SetVlanStackAction(v E_VlanTypes_VlanStackAction) {
	t.VlanStackAction = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_IngressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_IngressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_IngressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_IngressMapping.
func (*Interface_Subinterface_Vlan_IngressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match YANG schema element.
type Interface_Subinterface_Vlan_Match struct {
	DoubleTagged                *Interface_Subinterface_Vlan_Match_DoubleTagged                `path:"double-tagged" module:"openconfig-vlan"`
	DoubleTaggedInnerList       *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList       `path:"double-tagged-inner-list" module:"openconfig-vlan"`
	DoubleTaggedInnerOuterRange *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange `path:"double-tagged-inner-outer-range" module:"openconfig-vlan"`
	DoubleTaggedInnerRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange      `path:"double-tagged-inner-range" module:"openconfig-vlan"`
	DoubleTaggedOuterList       *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList       `path:"double-tagged-outer-list" module:"openconfig-vlan"`
	DoubleTaggedOuterRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange      `path:"double-tagged-outer-range" module:"openconfig-vlan"`
	SingleTagged                *Interface_Subinterface_Vlan_Match_SingleTagged                `path:"single-tagged" module:"openconfig-vlan"`
	SingleTaggedList            *Interface_Subinterface_Vlan_Match_SingleTaggedList            `path:"single-tagged-list" module:"openconfig-vlan"`
	SingleTaggedRange           *Interface_Subinterface_Vlan_Match_SingleTaggedRange           `path:"single-tagged-range" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match) IsYANGGoStruct() {}

// GetOrCreateDoubleTagged retrieves the value of the DoubleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	t.DoubleTagged = &Interface_Subinterface_Vlan_Match_DoubleTagged{}
	return t.DoubleTagged
}

// GetOrCreateDoubleTaggedInnerList retrieves the value of the DoubleTaggedInnerList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	t.DoubleTaggedInnerList = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList{}
	return t.DoubleTaggedInnerList
}

// GetOrCreateDoubleTaggedInnerOuterRange retrieves the value of the DoubleTaggedInnerOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	t.DoubleTaggedInnerOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange{}
	return t.DoubleTaggedInnerOuterRange
}

// GetOrCreateDoubleTaggedInnerRange retrieves the value of the DoubleTaggedInnerRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	t.DoubleTaggedInnerRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange{}
	return t.DoubleTaggedInnerRange
}

// GetOrCreateDoubleTaggedOuterList retrieves the value of the DoubleTaggedOuterList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	t.DoubleTaggedOuterList = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList{}
	return t.DoubleTaggedOuterList
}

// GetOrCreateDoubleTaggedOuterRange retrieves the value of the DoubleTaggedOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	t.DoubleTaggedOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange{}
	return t.DoubleTaggedOuterRange
}

// GetOrCreateSingleTagged retrieves the value of the SingleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t.SingleTagged != nil {
		return t.SingleTagged
	}
	t.SingleTagged = &Interface_Subinterface_Vlan_Match_SingleTagged{}
	return t.SingleTagged
}

// GetOrCreateSingleTaggedList retrieves the value of the SingleTaggedList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	t.SingleTaggedList = &Interface_Subinterface_Vlan_Match_SingleTaggedList{}
	return t.SingleTaggedList
}

// GetOrCreateSingleTaggedRange retrieves the value of the SingleTaggedRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	t.SingleTaggedRange = &Interface_Subinterface_Vlan_Match_SingleTaggedRange{}
	return t.SingleTaggedRange
}

// GetDoubleTagged returns the value of the DoubleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t != nil && t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	return nil
}

// GetDoubleTaggedInnerList returns the value of the DoubleTaggedInnerList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t != nil && t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	return nil
}

// GetDoubleTaggedInnerOuterRange returns the value of the DoubleTaggedInnerOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t != nil && t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	return nil
}

// GetDoubleTaggedInnerRange returns the value of the DoubleTaggedInnerRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t != nil && t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	return nil
}

// GetDoubleTaggedOuterList returns the value of the DoubleTaggedOuterList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t != nil && t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	return nil
}

// GetDoubleTaggedOuterRange returns the value of the DoubleTaggedOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t != nil && t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	return nil
}

// GetSingleTagged returns the value of the SingleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t != nil && t.SingleTagged != nil {
		return t.SingleTagged
	}
	return nil
}

// GetSingleTaggedList returns the value of the SingleTaggedList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t != nil && t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	return nil
}

// GetSingleTaggedRange returns the value of the SingleTaggedRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t != nil && t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DoubleTagged.PopulateDefaults()
	t.DoubleTaggedInnerList.PopulateDefaults()
	t.DoubleTaggedInnerOuterRange.PopulateDefaults()
	t.DoubleTaggedInnerRange.PopulateDefaults()
	t.DoubleTaggedOuterList.PopulateDefaults()
	t.DoubleTaggedOuterRange.PopulateDefaults()
	t.SingleTagged.PopulateDefaults()
	t.SingleTaggedList.PopulateDefaults()
	t.SingleTaggedRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match.
func (*Interface_Subinterface_Vlan_Match) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTagged struct {
	InnerVlanId *uint16 `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId *uint16 `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// SetInnerVlanId sets the value of the leaf InnerVlanId in the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) SetInnerVlanId(v uint16) {
	t.InnerVlanId = &v
}

// SetOuterVlanId sets the value of the leaf OuterVlanId in the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) SetOuterVlanId(v uint16) {
	t.OuterVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTagged.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList struct {
	InnerVlanIds []uint16 `path:"config/inner-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId  *uint16  `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) IsYANGGoStruct() {}

// GetInnerVlanIds retrieves the value of the leaf InnerVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanIds is set, it can
// safely use t.GetInnerVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetInnerVlanIds() []uint16 {
	if t == nil || t.InnerVlanIds == nil {
		return nil
	}
	return t.InnerVlanIds
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// SetInnerVlanIds sets the value of the leaf InnerVlanIds in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) SetInnerVlanIds(v []uint16) {
	t.InnerVlanIds = v
}

// SetOuterVlanId sets the value of the leaf OuterVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) SetOuterVlanId(v uint16) {
	t.OuterVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange struct {
	InnerHighVlanId *uint16 `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16 `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// SetInnerHighVlanId sets the value of the leaf InnerHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetInnerHighVlanId(v uint16) {
	t.InnerHighVlanId = &v
}

// SetInnerLowVlanId sets the value of the leaf InnerLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetInnerLowVlanId(v uint16) {
	t.InnerLowVlanId = &v
}

// SetOuterHighVlanId sets the value of the leaf OuterHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetOuterHighVlanId(v uint16) {
	t.OuterHighVlanId = &v
}

// SetOuterLowVlanId sets the value of the leaf OuterLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetOuterLowVlanId(v uint16) {
	t.OuterLowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange struct {
	InnerHighVlanId *uint16  `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16  `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId     []uint16 `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetOuterVlanId() []uint16 {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// SetInnerHighVlanId sets the value of the leaf InnerHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetInnerHighVlanId(v uint16) {
	t.InnerHighVlanId = &v
}

// SetInnerLowVlanId sets the value of the leaf InnerLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetInnerLowVlanId(v uint16) {
	t.InnerLowVlanId = &v
}

// SetOuterVlanId sets the value of the leaf OuterVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetOuterVlanId(v []uint16) {
	t.OuterVlanId = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList struct {
	InnerVlanId  *uint16  `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanIds []uint16 `path:"config/outer-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanIds retrieves the value of the leaf OuterVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanIds is set, it can
// safely use t.GetOuterVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetOuterVlanIds() []uint16 {
	if t == nil || t.OuterVlanIds == nil {
		return nil
	}
	return t.OuterVlanIds
}

// SetInnerVlanId sets the value of the leaf InnerVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) SetInnerVlanId(v uint16) {
	t.InnerVlanId = &v
}

// SetOuterVlanIds sets the value of the leaf OuterVlanIds in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) SetOuterVlanIds(v []uint16) {
	t.OuterVlanIds = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange struct {
	InnerVlanId     *uint16 `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// SetInnerVlanId sets the value of the leaf InnerVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetInnerVlanId(v uint16) {
	t.InnerVlanId = &v
}

// SetOuterHighVlanId sets the value of the leaf OuterHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetOuterHighVlanId(v uint16) {
	t.OuterHighVlanId = &v
}

// SetOuterLowVlanId sets the value of the leaf OuterLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetOuterLowVlanId(v uint16) {
	t.OuterLowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTagged struct {
	VlanId *uint16 `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_Match_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// SetVlanId sets the value of the leaf VlanId in the Interface_Subinterface_Vlan_Match_SingleTagged
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) SetVlanId(v uint16) {
	t.VlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTagged.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedList struct {
	VlanIds []uint16 `path:"config/vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) IsYANGGoStruct() {}

// GetVlanIds retrieves the value of the leaf VlanIds from the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanIds is set, it can
// safely use t.GetVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) GetVlanIds() []uint16 {
	if t == nil || t.VlanIds == nil {
		return nil
	}
	return t.VlanIds
}

// SetVlanIds sets the value of the leaf VlanIds in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) SetVlanIds(v []uint16) {
	t.VlanIds = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedList.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedRange struct {
	HighVlanId *uint16 `path:"config/high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	LowVlanId  *uint16 `path:"config/low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) IsYANGGoStruct() {}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetLowVlanId retrieves the value of the leaf LowVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowVlanId is set, it can
// safely use t.GetLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetLowVlanId() uint16 {
	if t == nil || t.LowVlanId == nil {
		return 0
	}
	return *t.LowVlanId
}

// SetHighVlanId sets the value of the leaf HighVlanId in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) SetHighVlanId(v uint16) {
	t.HighVlanId = &v
}

// SetLowVlanId sets the value of the leaf LowVlanId in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) SetLowVlanId(v uint16) {
	t.LowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedRange.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}
